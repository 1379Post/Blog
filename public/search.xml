<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>知乎收藏·如何评价children of a dead earth?</title>
      <link href="/2019/%E7%9F%A5%E4%B9%8E%E6%94%B6%E8%97%8F%C2%B7%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7children-of-a-dead-earth/"/>
      <url>/2019/%E7%9F%A5%E4%B9%8E%E6%94%B6%E8%97%8F%C2%B7%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7children-of-a-dead-earth/</url>
      
        <content type="html"><![CDATA[<p> 原链接：<a href="https://www.zhihu.com/question/306105085/answer/631834753" target="_blank" rel="noopener">如何评价children of a dead earth? - GSUI5051的回答 - 知乎</a></p><p>打波广告：本人是B站目前唯一的Children of a Dead Earth模块设计教程作者，在B站搜Children of a Dead Earth可以看到我做的模块设计简介视频一图评价：<img src="https://pic4.zhimg.com/50/v2-59208985c7c6152850248119055cf30e_hd.jpg" alt>一句话评：史上最科学准确的太空战斗模拟器。（The most scientifically accurate space warfare simulator ever made. ）如果你真的想知道空间作战究竟是怎样的，那这就是你想要的游戏。这个游戏之前在知乎上已经有人介绍过了，此处不再进行过多介绍。游戏的背景是地球人由于战争，把地球变成和金星一样的死球，然后他们被迫成为太阳系物种。但是按照人类目前的技术，只有化学火箭和效率就比化学火箭高一点的核热火箭，为了保证delta-v, 只能是堆燃料，出现了几百上千吨的燃料罐，对于行星际战争来说就相当于爬一样。游戏中你被任命为一名海军上将，需要在太阳系全面战争中完成你的作战任务，还需要你利用各种资源，探索各种战术，以少量军力去摧毁一个大型舰队。不同关卡敌人的作战风格不同，你需要采取不同的战术完成任务。每一关涉及到的挑战都不同，比如高引力下的轨道转移、与激进的敌人作战、行星际轨道转移、紧迫的时间和/或delta-v预算、精准战斗。这个游戏的轨道由辛积分N体模拟器计算，能完成多体引力下长时间小推力作用下航天器的轨道，此时航天器的轨迹不再是传统意义上的圆锥曲线，而是螺旋形。<img src="https://pic1.zhimg.com/50/v2-38fe38365082452253d3d0d0b4e6a728_hd.jpg" alt>)至于在轨道规划中看到一些直线，这说明这个积分器是数值积分法，不过多体问题本来就没有解析解，但是可以求出航天所需的数值解。（也有可能是轨道仿真出了bug）更重要的是，如果你在创意工坊订阅了社区材料包和社区聚变包，你甚至可以用到各种目前仅存在理论之中或者是只能少量制造的材料，制造各种性能极高的模块，还可以制造聚变推进火箭！<img src="https://pic4.zhimg.com/50/v2-f14277cd0435a2c6e37e55d874e3eb73_hd.jpg" alt>)聚变推进火箭<img src="https://pic3.zhimg.com/50/v2-adc414961e7946ee51ef103e0c29ba85_hd.jpg" alt>)大推力大功耗的离子推进器<img src="https://pic3.zhimg.com/50/v2-ad161aedf2f416dd27f664943c7bd744_hd.jpg" alt>大功率核反应堆这几张图充分说明了，打了材料包之后，就是石墨烯、碳炔和各种陶瓷的天下了这个游戏对于轨道作战的特征模拟得淋漓尽致。轨道转移节奏极慢，但战斗却是在电光火石中结束，战斗的节奏完全取决与你交会时的相对速度。战斗中你甚至还可以关闭发动机，开着激光，采用战术滑行的方法，让敌舰消耗燃料（也可以说是delta-v）来追上你，你就有2次攻击的机会了，尤其是在高速拦截敌方主力舰的时候。你还可以选择用导弹和无人机的混成编队，以较慢的相对速度，交会时用导弹掩护无人机。轨道作战需要注意一点：在太空中，能量是廉价的，物质是昂贵的（As a general rule, in space, energy is cheap but matter is expensive. –Atomic Rockets, Project Rho）这就是为什么战斗中会有战术滑行的操作。电影中的太空战：奇形怪状的飞船，各种奇怪的飞机执行各种骚气的机动机枪稳如狗，激光亮瞎狗眼（这个是各种电影和EVE或者太空工程师里面的太空战）<img src="https://pic4.zhimg.com/50/v2-408b2c1c30c198676323ce73896b8568_hd.jpg" alt>)真实的太空战：飞行两个月，接敌半分钟，成败在于轨道每秒几公里的相对速度，无人机群全速突防，核导弹凭借极高的相对速度冲向目标进行轰炸，激光武器满功率运转，轨道炮扫射，散热板红热化，半分钟结束战斗各种弯曲的枪炮弹道，激光枪只能看到光点<img src="https://pic2.zhimg.com/50/v2-9d17bf6f0f33441c01b1bdc0f8804d13_hd.jpg" alt>太空飞行的本质是轨道调整，光是轨道力学本身就已经是一门课了，理解切向、径向、法向推力对轨道的影响就已经是有难度了，更不用说什么空间交会、高速拦截、空间导航了，同时还有一个违反直觉的常识：在轨道上不用开发动机就能往前走。如果以轨道力学为基础给大家飞，估计很多人都直接掉进行星里了。这个游戏的模拟精度可以说是比坎巴拉太空计划还要高，装甲模拟用的都是有限元的算法，还具有子系统损伤的设定。坎巴拉里面的部件只有0和1两种状态，要么就在航天器上，要么就一声巨响和火光之后就没了。这个游戏里面的部件可以有战损、供能不足、控制所需人员不足。你甚至可以造出一门高精度的炮，瞄准对方太空战舰尾部的反应堆和火箭，进而瘫痪敌人的战舰。这个游戏有两个任务涉及到精准战斗，这两个任务中你需要瘫痪敌方的战舰，不能摧毁敌方的船员舱。游戏的背景音乐采用太空音乐家Nigel John Stanford在专辑Solar Echoes中的音乐，不同关卡的背景音乐不同，在关卡编辑器中可以自定义各个关卡的背景音乐。</p><p>但是游戏本身的模拟是有缺陷的，在此引用游戏官方中文作者在Steam评测中提到的：舰船没有考虑结构强度，3 毫米厚 100 米长的散热板可以在 10G 的加速度下毫发无损。功率太容易堆高，输出 2GW 的功率简直是家常便饭。激光的弧光灯光谱十分诡异，跟现实中的毫无相似之处，使得激光器跟现实比效率严重偏低。（怀疑是作为平衡功率太高的手段）。没有考虑到核燃料的提纯费用，无论何时使用 97% 纯度的核燃料总是最棒的。类似的，很多材料的精细加工费也没考虑。我是想象不大出如何将那些高杨氏模量的材料加工成 1 毫米口径的喷嘴还很便宜的。你可以用 1 克的材料作为最大的轨道炮的炮弹，完全不需要考虑集肤效应给出的侵蚀。钻石可以承受 3600K 的高温，现实中的钻石在这个温度下早就变成石墨了。电阻火箭即使算上分子键中蕴含的能量，依然输出了太高的推进功率。在 RP-1 作为燃料时尤其明显。你可以用各种高度侵蚀性的东西作为燃料或推进剂等等，而不需要考虑化学反应。例如氟推进剂。没有任何理由使用除了铀以外的裂变物。超强辐射的无人机塞进弹药模块里就没辐射了。发射出去了也没有。没有 RCS。（准确的说有，但是游戏里对有动力飞船的旋转与转向计算非常诡异。）弹药库和发射器之间不需要连接，散热器也是，你哪怕随距离额外计算重量和成本也好。装弹机不需要空间。没有超导体。低温燃料耗散也没有模拟。第4个现在已经完善了，核燃料纯度越高，成本越高。我在这里想说的是一个最大的硬伤：火箭发动机的设计。真实的火箭循环是这样的：</p><p><img src="https://pic1.zhimg.com/50/v2-cca7ef7a47fc0063aa48a0198ec683fd_hd.jpg" alt>分级燃烧（高压补燃）循环与燃气发生器循环</p><p><img src="https://pic4.zhimg.com/50/v2-73a80519afdb87dce733b21632eb7341_hd.jpg" alt>全流量分级燃烧循环</p><p><img src="https://pic1.zhimg.com/50/v2-f448c1c1f0e06a3bc2c2e999026b56a4_hd.jpg" alt>膨胀循环</p><p>真正的火箭发动机不只有一个涡轮泵，需要消耗一部分燃料和氧化剂，用于推动加压用的涡轮泵，或者是直接用一部分燃料推动涡轮泵。而在这个游戏中，只有一个动力来源未知的涡轮泵，严重不符合实际。另外一个就是游戏对部件过热处理极其不科学，飞到距离太阳这么近的地方，飞船都不会坏，而且这个飞船是没有装甲保护的，详情见图<img src="https://pic3.zhimg.com/50/v2-e404c456ca19b605e3fce87a2d99a7b2_hd.jpg" alt>在坎巴拉太空计划里面，如果你把飞行器飞到离太阳这么近的地方，早就过热烧毁了。总而言之，这个游戏可以说是最接近真实的太空战斗模拟器，从轨道作战，到模块设计，游戏中的每一个方面，都来自工程与物理教科书和各种白皮书中科学有效的定律和方程。目前此游戏已出官方中文，创意工坊的材料包和聚变包都有了汉化，如果你玩过坎巴拉太空计划或者是熟悉轨道力学，那么这个游戏对你来说上手难度降低了一个级别，但是多体引力下的轨道定向依然十分棘手，而这个游戏允许你修改参考系，规划拦截交战和轨道交会更方便了。游戏允许你设计舰船和各种模块，如发动机、燃料罐、各种武器、核弹和破片弹等。舰船设计相对简单一些，而模块设计的话，你可能需要在相关领域有个学位，或者是先了解这个模块的基本工程技术信息。游戏中自带信息查询，不了解这个模块是如何工作的可以先阅读模块相关的信息，还提供了参考文献，我玩过的游戏中目前就只有这个游戏是在游戏文本中给出参考文献的了，瘟疫公司也只有一个wiki链接。游戏的作者甚至还做了一个网站，解释了游戏中几乎所有的内容：Children of a Dead Earth - The Science Behind the Game​childrenofadeadearth.wordpress.com如果你是硬科幻真爱粉或者是以前玩过坎巴拉太空计划的话，这个游戏很适合你，虽然此游戏现已自带官方中文（创意工坊已经有了中文、法文、德文、俄文、日文补丁），但是入坑需谨慎。根据Steam成就统计中的信息，截止至2019年8月19日，这个游戏的通关率为4.4%, 全银1.3%, 全金0.6%. 答主我已经在2019年8月19日成为这0.6%中的一员了。<img src="https://pic3.zhimg.com/50/v2-519cdf7e8c5d8445f51cc625428bc0d1_hd.jpg" alt>)这么低的原因有两个方面：硬核级别的模拟飞行游戏受众的确极少（你想想FS:X多少人能飞完一整个跨洋航线）这个游戏里面涉及到的工程学和科学知识，足以使无数螳臂当车的玩家退坑。<img src="https://pic2.zhimg.com/50/v2-336659ad49f53b9aa18dfea6a0e6ab0d_hd.jpg" alt>最后再打一波广告，欢迎加入死球孩子游戏交流群，群号码：194105325，硬科幻爱好者可加CDE交流群131688707讨论最硬核的航空航天科学和军事科技。跋</p><blockquote><p> 浩瀚宇宙，无垠太空。</p><p>运筹帷幄，深谋远虑。</p><p>千里迢迢，万里奔赴。</p><p>狭路相逢，剑拔弩张。</p><p>金鼓连天，雷霆万钧。</p><p>电光石火，灰飞烟灭。</p><p>十年一剑，高下立见。</p><p>原作者：Steam用户Yan_Lyn</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知乎收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知乎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知乎收藏·Minecraft（我的世界）中最适合当货币的物品是什么？</title>
      <link href="/2019/%E7%9F%A5%E4%B9%8E%E6%94%B6%E8%97%8F%C2%B7Minecraft%EF%BC%88%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%EF%BC%89%E4%B8%AD%E6%9C%80%E9%80%82%E5%90%88%E5%BD%93%E8%B4%A7%E5%B8%81%E7%9A%84%E7%89%A9%E5%93%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2019/%E7%9F%A5%E4%B9%8E%E6%94%B6%E8%97%8F%C2%B7Minecraft%EF%BC%88%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%EF%BC%89%E4%B8%AD%E6%9C%80%E9%80%82%E5%90%88%E5%BD%93%E8%B4%A7%E5%B8%81%E7%9A%84%E7%89%A9%E5%93%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>原链接：<a href="https://www.zhihu.com/question/329730508/answer/770782283" target="_blank" rel="noopener">Minecraft（我的世界）中最适合当货币的物品是什么？ - 神芜夜的回答 - 知乎</a></p><p>最合适的当然是通过记分板所制作的虚拟货币，兼顾了便于取用（玩家对系统层面，当然也可以用技术进行玩家间的货币交换），便于携带，无法复制刷取的优点</p><p>如果你想要无指令的情况下制造货币，在这里推荐使用成书——</p><p>1.首先使用书与笔创建一本成书“原作”，里面可以包含一些内容，可以用于防伪。最重要的防伪在于你可以使用颜色代码，特别是在基岩版中使用颜色代码§后可以跟任何字符，并使其后面的一个字符不可见（JAVA版情况似乎较为复杂，这里不作详细说明）。例如你可以在书中书写以下代码：</p><p>1§1§r0§0§r0§0§r元§e§r</p><p>这样在做成成书之后，其他人只能看到黑色的100元，但是无法解读其中究竟隐藏了什么样的颜色代码。你甚至可以随意插入大量的颜色代码，然后做成成书，这样在无法读取nbt（也就是不作弊）的情况下，这本书的防伪内容对于所有人都是黑箱状态。</p><p>你将书命名并署名，可以在书名处任意地设置书所代表的面额。</p><p>2.获取成书（原作）之后，可以将它和书与笔一起放在工作台上，获取这本书的副本。副本的内容和原作相同，但是拥有一个副本标签，与原作区分。原作可以留作类似于权力声明之类的东西。</p><p>3.你可以将副本分发给信任的人，拥有副本的人就相当于拥有了铸币权。</p><p>获取副本之后，你可以在将其和书与笔合成，获取“副本的副本”。副本的副本就可以作为钱币在市场上流通了。</p><p>注：以下提到的钱币即为“副本的副本”</p><p>防伪：完全相同的书是可以堆叠的，因此如果与真正的流通钱币无法堆叠，那么该书就是假币。因此该方法要求卖家拥有一整套钱币至少一份。如果出现失误，拥有铸币权者将同时拥有最终鉴定权。</p><p>无法复制：副本的副本无法再被简单复制，因此这种货币是十分安全的。其实理论上，将原作作为原币，副本作为流通货币是同样可行的。即便副本还可以被复制，但是复制的产品依然可以与真币简单区分。</p><p>面值和便携：通过修改书名来获取便于读取的面额，每种面额的钱币应该拥有不同的防伪代码（书内容）。16本完全相同的书可以堆叠在同一个物品栏中，通过面值组合，便携性较高。</p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 知乎收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知乎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知乎收藏·战机的后掠翼，变后掠翼，三角翼，鸭翼各自的特点是什么？</title>
      <link href="/2019/%E7%9F%A5%E4%B9%8E%E6%94%B6%E8%97%8F%C2%B7%E6%88%98%E6%9C%BA%E7%9A%84%E5%90%8E%E6%8E%A0%E7%BF%BC%EF%BC%8C%E5%8F%98%E5%90%8E%E6%8E%A0%E7%BF%BC%EF%BC%8C%E4%B8%89%E8%A7%92%E7%BF%BC%EF%BC%8C%E9%B8%AD%E7%BF%BC%E5%90%84%E8%87%AA%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2019/%E7%9F%A5%E4%B9%8E%E6%94%B6%E8%97%8F%C2%B7%E6%88%98%E6%9C%BA%E7%9A%84%E5%90%8E%E6%8E%A0%E7%BF%BC%EF%BC%8C%E5%8F%98%E5%90%8E%E6%8E%A0%E7%BF%BC%EF%BC%8C%E4%B8%89%E8%A7%92%E7%BF%BC%EF%BC%8C%E9%B8%AD%E7%BF%BC%E5%90%84%E8%87%AA%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p> 原链接：<a href="https://www.zhihu.com/question/317737367/answer/635046996" target="_blank" rel="noopener">战机的后掠翼，变后掠翼，三角翼，鸭翼各自的特点是什么？ - KOP115OF的回答 - 知乎</a></p><p>作者：KOP115OF</p><p>这个问题简直就是一部二战后战机气动发展史，要是往详细了说能说上好几天，我还是尽量简短一些。</p><p>首先先上一张二战时期战斗机的图片：</p><p><img src="https://pic3.zhimg.com/50/v2-e7c059175ed0ab39a3f33635a33087ae_hd.jpg" alt="img"></p><p>你会发现二战时期的战机差不多都是这种平直翼加活塞螺旋桨的飞机。平直翼➕螺旋桨的组合赋予了飞机很好的起降性能。</p><p>当时的设计师们发现不管怎么增加发动机马力，可是飞机的速度却很难上去。思来想去是发动机的问题，螺旋桨难以带来更快的速度，于是在二战末喷气式发动机出现了。</p><p>人们得到了能飞高速的发动机，自然也没有放弃追逐高速的脚步，这个时候用什么样的翼型成了困扰设计师最大的问题。</p><p><img src="https://pic3.zhimg.com/50/v2-94082ddaffae1ea10f6989799df806d8_hd.jpg" alt="img"></p><p>首先来看歼五，这种早期喷气战斗机，设计师们尝试增加后掠角来增加飞机的速度，的确飞机速度相对于二战螺旋桨是上去了，可是依然没有达到人们突破音速的追求。</p><p>于是设计师们开始思考，是不是后掠角还不够大？</p><p><img src="https://pic3.zhimg.com/50/v2-33fb000b58bb46cb3de9ef4f410d271e_hd.jpg" alt="img"></p><p>于是后期的一代机就成了歼六这样大后掠角，可是后掠角加大带来反而是翼尖失速和起降性能差。（补充一下翼尖失速：战机正常工作需要气流像红色箭头那样划过机翼，后掠翼带来的问题就是气流沿着机翼往翼尖发散了，气流这样走就影响了战机的正常工作。）</p><p><img src="https://pic1.zhimg.com/50/v2-e1e5d89d0c5f1e57aaa97e6b021deca3_hd.jpg" alt="img"></p><p>人们不得不往机翼上加翼刀来抑制气流的展向流动，从而防止翼尖失速的产生。 （这些机翼上的小隔板就是翼刀）</p><p><img src="https://pic3.zhimg.com/50/v2-ef664b5632b3d5092d08af4e8336d09a_hd.jpg" alt="img"></p><p>设计师们就发现这样夸张的后掠角速度没上去多少显然这是一条邪路。单纯的后掠翼是战后飞机设计师探索喷气式飞机迈出的第一步，优点是相比平直翼，速度上去了，但也就是仅此而已。</p><p><img src="https://pic1.zhimg.com/50/v2-568bee853c115f0806ee587f9f10269e_hd.jpg" alt="img"></p><p>既然一味的加大后掠角不行，那么怎样的机翼才能实现超音速呢？</p><p>要跨越音速就必须要直面音障，要尽可能地把机身收在机头引起的激波后面。于是设计师们提出：  机翼要坚固，要简洁——三角翼几乎完美地满足了设计师的需求，三角够坚固，把机身收在了机头激波的后面，最大程度上减少了超音速所带来的阻力，甚至还出现了达索那样把平尾都省了的无尾三角翼布局。</p><p><img src="https://pic2.zhimg.com/50/v2-f7f19e7f8d002217295ccf5b7b4d7872_hd.jpg" alt="img"></p><p>如果是没有收到机头造成的激波后面，则会有更多的点引发激波，带来更大阻力的同时也对战机结构带来了挑战。</p><p><img src="https://pic4.zhimg.com/50/v2-fc9f26fad2ce589b62b1dfcbc9c3063d_hd.jpg" alt="img"></p><p>机翼收到机头激波后面则就好得多</p><p>（以上两张图截自军武次位面第二期15集～我作图质量太渣，画了几次都不能用无奈只能去盗图了……）</p><p><img src="https://pic4.zhimg.com/50/v2-990a93c1de9f2d6cb40fb3ba4572c760_hd.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/50/v2-3bf52e41810257a665fdb6fc00c4717a_hd.jpg" alt="img"></p><p>三角翼也是人们探索战机超音速迈出的重要一步，人类成功跨过了音速，2倍音速，冲击了三倍音速但是速度快就意味着战斗力强吗？ 当然不是，三角翼赋予了战机飞过音障的能力，翼尖失速的问题依然得靠翼刀解决。</p><p>这种人操火箭带来了高速，也带来了亚音速机动性的平庸和超长的起降距离，记录可以这么刷，但是空战可不是刷记录。</p><p><img src="https://pic1.zhimg.com/50/v2-568bee853c115f0806ee587f9f10269e_hd.jpg" alt="img"></p><p>成功跨过了音障的设计师开始思考平直翼起降好但是飞不快，三角翼能飞快但是起降与低速性能不好，怎样才能设计一款低速起降好又能飞高速的飞机呢？——做一架变形金刚！</p><p><img src="https://pic4.zhimg.com/50/v2-d5d321725e5b1db2cc9705c73845aeed_hd.jpg" alt="img"></p><p>你看这小家伙，翅膀打开了是平直翼，收起来又像个三角翼能快能慢，就是重了点，上面这架米格23是手动档的，上个天还得不停换挡影响空战心情，还是美国人有黑科技，搞了自动挡的大猫，间隙还有气囊来完善各种后掠角下的气动外形。只是自动档就不能享受驾驶飞机的乐趣了……</p><p><img src="https://pic3.zhimg.com/50/v2-62d0e4979ffc3153338d72ade7ec3afc_hd.jpg" alt="img"></p><p>变后掠翼解决了战机同时拥有高速和低速性能的问题，当然在战斗机上每一克重量都十分金贵，付出的代价就是结构重量。(但是变后掠翼解决了轰炸机航程与速度不可兼得的问题，当然这又是别的故事了)</p><p>～～～～～～～～～～～～～～～～～～～～～～</p><p>结构重量怎么能忍！翼刀、变后掠翼什么的都不能忍！——处女座的设计师</p><p>苏联人在米格23上惊奇的发现，米格23在飞行的时候，翼尖失速的现象并不是很明显。难道是共产主义信仰加成？当然不是，研究了半天原来是可变后掠翼与机身的连接处豁口在飞行时拉出的涡流，涡流在机翼上形成了类似于虚拟翼刀的作用。明白了真相的苏联设计师大惊：原来还可以这样玩！（Ps：美国人其实比苏联人早些就在气动实验室里搞清楚了这个问题）之后的战机发展就是涡流的世界了。</p><p><img src="https://pic3.zhimg.com/50/v2-9b73699863f2a6fedd1c7e0bf9d7bc73_hd.jpg" alt="img"></p><p>人们开始研究怎样才能在战机主翼上拉出涡流，并且更好地利用它。</p><p>Ps：评论区有大佬让补充一下涡升力的知识：</p><p>空气在接触物体突起边缘时容易形成涡流，大多数时候，涡流会影响控制翼面正常工作，所以大多数飞机平尾和主翼都是错开的不在一个平面上，这样主翼引起的涡流就不容易干扰平尾。 </p><p>飞机能够飞起来，就包含了一个很经典的知识：中学时代物理课上，老师让我们在两张平行放置的白纸中间吹气使纸张中间的气流加速，这个时候两张纸就因为压力差的原因合上了。飞机也是如此，机翼上下方的气流流速不同，形成的升力将飞机抬了起来。</p><p>随着气动技术的发展，设计师们发现有的时候经过翼面上的涡流也会产生有利影响，当涡流从主翼上方经过时，形成低压区，加大了机翼上下方的压力差，达到了增大升力的效果。所以设计师们也就想到在主翼前方加一个后掠角极大的突起（边条）来拉出涡流。</p><p> 于是出现了以F16，苏27这样的带有边条翼的战机，利用边条拉出的涡流赋予了这一批战机良好的起降能力和高亚音速能力，同时强大的发动机和后掠的机翼又保证了速度不慢，以前J8这样的高速三角翼飞机伴飞P3这样的低速螺旋桨飞机很容易出事故，换了苏27不仅能全程伴飞，心情不好了还能做个筒滚甚至能逼急了还能操控战机用尾翼切开你的发动机~</p><p><img src="https://pic1.zhimg.com/50/v2-70508302254e932a301cd2d9ccce7d1d_hd.jpg" alt="img"></p><p>再往后边条鼓的就越发的明显了，像是FA18EF，枭龙那样的哥特式大边条：</p><p>可以明显的看出拉出来的涡。</p><p><img src="https://pic3.zhimg.com/50/v2-4972f40660f110601c2033dd0eb19ede_hd.jpg" alt="img"></p><p>~<del>以上插播一些问题中没问的边条翼知识，不然总觉得接不到鸭翼上</del></p><p>战斗机气动外形发展到这个阶段，基本就已经没有啥大的问题了，人操火箭般的高速有了，高亚音速机动性已经可以跟上螺旋桨飞机了，结构重量也减下去了，还有啥？</p><p>设计师：我觉得还可以在平尾上做一些文章….</p><p>于是设计师们思考平尾放在后面是用来调整战机俯仰，我们把它放到主翼的前面，这样既不被主翼上的气流干扰，又能操控战机俯仰，并且能拉出涡流，还能在飞机降落的时候当减速板用，这样一举多得岂不美哉？</p><p><img src="https://pic4.zhimg.com/50/v2-ba59d81c99063139e68d10d23a2e1bd8_hd.jpg" alt="img"></p><p>想法虽好，但是实施起来又是另一番景象，平尾的前置带来的升力中心前移使得飞机的安定性下降，往好了说就是更灵活了，操作杆动一动飞机能动三动，往坏了说就是这飞机像一匹烈马根本没法驾驭。</p><p>于是电传操控则成了鸭式布局飞机的必备，靠着无数风洞试验编写出的飞控软件再加上算力强大的计算机，帮助人来驾驭这个飞机。这时的人们发现，这匹驯服了的野马不仅听话，而且瞬时机动性能强大，能快速地将机头指向目标，瞄准开火先敌一步，即便主翼是三角翼也能做到短距起降，亚音速性能也是杠杠的，就是飞控难写了点…..</p><p>至此题主问的这些战斗机气动布局我大概说了一遍，再往后就是四代机的故事了。</p><p><img src="https://pic1.zhimg.com/50/v2-568bee853c115f0806ee587f9f10269e_hd.jpg" alt="img"></p><p>战斗机的发展本质上就是提出问题，解决问题，然后提出新问题的过程。之前战斗机气动布局的发展大体上是线性的，设计师们攻克了一个又一个连续的技术难关，让战机性能提升。</p><p>这个时候的战斗机虽然还面临着一系列的问题（比如评论区有大佬提到的人操火箭的问题，还有超音速后只能三十秒真男人的问题），但是基本已经够用了，不然这一代飞机的气动也不会从七十年代一路用到现在。</p><p>要讨论第四代战机，我们就必须去看另外一颗科技树：</p><p>今天我们虽然嘴上说着把新一代以隐身外形为主打设计的战斗机划为第四代战斗机，但是单独把隐身飞机拎出来讨论，很多人又喜欢把这一代飞机称之为第三代隐身战机，其原因在于最早期的隐身飞机并不是为空战而设计的。</p><p>在那个战斗机并不愿意为对地攻击付出一磅重量的年代，危险系数最高的要数那些突破敌方防空网去执行踹门打击任务的飞行员，于是那一批研究对地打击飞机的设计师们一直在思考：要怎么做，才能让那些飞行员不被对方雷达发现？</p><p>雷达波与可见光本质上属于波的范畴，于是讨论这个问题，我们可以用可见光来说明：</p><p>中学知识告诉我们在漆黑的夜里，我们打着手电筒照路，这个时候人眼能看到物体，得益于物体表面不规则引起的漫反射，如果我们用光滑的镜面把手电筒的光线反射到夜空呢？是不是就成了一抹黑？</p><p>再举一个例子：</p><p><img src="https://pic2.zhimg.com/50/v2-15ffe514f23a85a88e519550fe118a0d_hd.jpg" alt="img"></p><p>自行车尾部反射灯，大家都不陌生，为的就是在夜里尽可能的让其他行人发现你，我们如果将其拆开，会发现里面是一个一个的直角反射面：</p><p><img src="https://pic2.zhimg.com/50/v2-f9ee759a4ac79d88b68ca6c513c2fd38_hd.jpg" alt="img"></p><p>感兴趣可以去看看光学大佬回答：<a href="https://www.zhihu.com/question/56823046" target="_blank" rel="noopener">https://www.zhihu.com/question/56823046</a></p><p> （上面的图片也来自于这个回答）</p><p>雷达发射天线就好比手电筒，雷达接收机就好比人的眼睛。所以想要让雷达发现不了，就必须让机身光滑不形成漫反射，尽量把雷达波反射到无关紧要的方向，并且要避免战机上出现直角。</p><p>飞机要飞什么是不可或缺的？答案是机翼！ 所以一切与雷达反射面相关的东西除了机翼，能不要就不要，这就是飞翼式布局。</p><p><img src="https://pic1.zhimg.com/50/v2-0c996563c0cf82917b0e408513400b3c_hd.jpg" alt="img"></p><p>在这样理论的指导下，F117应运而生，是不是镜面？没有一个直角？是不是只有一个大机翼？为了隐身采用倾斜式全动垂尾，别说是上世纪八十年代，即便在今天也是妥妥的黑科技。</p><p>然而F117为了隐身牺牲太多，之前我们讲涡升力的时候讲过，战机上的突起会引发涡流干扰战机操控翼面，这家伙身上全是突起。进气道用了遮挡处理导致推力偏低，内置弹仓设计又导致弹药挂在量不足，还有为了隐蔽必须夜间出航 还要无线电静默，完全没有自卫能力，一旦被发现必死无疑。</p><p>本身气动不佳再加上飞行员顶着被发现击落的压力胆战心惊地一个人夜间出航，还不能用无线电跟后台诉苦排解压力，导致F117虽然战绩辉煌，但是事故坠毁的117比被击落的要多得多……</p><p><img src="https://pic1.zhimg.com/50/v2-568bee853c115f0806ee587f9f10269e_hd.jpg" alt="img"></p><p>评论区有大佬指出117并不属于飞翼式布局，于是我考证了一下，这里应该是我疏忽了，我们现在来看看真.飞翼布局。</p><p>二战时候有一位元首，他在陆地上拥有着一座动物园的同时还在天上有着一座黑科技园，最早的飞翼式布局也要追溯到二战时期元首的黑科技。</p><p><img src="https://pic2.zhimg.com/50/v2-c2f9ed909faa2d81a67a7a4da9a09fbc_hd.jpg" alt="img"></p><p>Ho 2_29 世界上首架喷气式飞翼机，其实某种程度上它也是世界上第一架具有隐身性能的喷气式飞机，全机只用了极少数的钢材，其余为木质结构。</p><p>有人说它材料大量使用木材是为了隐身穿过盟军的防空雷达网，也有人说是为了降低机身重量增大航程从而深入打击盟军腹地，也有人说此时的德国已是强弩之末，用木头是迫不得已……总之这位哥已经被盟军缴获了好多年，可是江湖上哥的传说就没断过。</p><p>那就有人问了只不过是用木头做了架飞机，怎么就隐身了呢？其实这要从雷达的工作频段说起，常用的探测雷达工作在分米、厘米波波段，这个波段被人们称为微波。</p><p>是不是听起来耳熟，没错，我们食堂热剩菜剩饭的那个家伙发射的也是微波，因此我们可以用微波炉来说明问题：微波照射到极性、非极性跟金属材料上分别会出现吸收、透过、反射三种不同的现象。往日常了说你用一杯水放进微波炉，转三分钟水就开了，因为水是极性分子波的能量被吸收转换成了热。你把干燥的空塑料碗放进去转是不会升温的 因为波透过去了。但是千万不要尝试把金属不锈钢碗放进去，因为很可能一些老式微波炉设计不好，会把加热用的微波到处反射，弄坏微波炉是小，伤到人就不好了，毕竟人也是水做的……</p><p>（当然雷达也有用米波的，只是米波精度不高原本已经处在被淘汰的边缘，近些年来有人发现米波雷达反隐身效果不错，米波有源相控阵雷达被中国人搞得有声有色的）</p><p>Ho2-29的隐身性能很大程度上来自于它木质材料的透波属性。</p><p>话锋一转来到了世纪末，美国人在F117上尝到了甜头，可是117的外形的确是太反人类，有棱有角的机身加大空气阻力缩短了航程不说，安全性能也得不到保证。设计一款大航程大挂载的隐身飞机成为了设计师们思考的问题，于是也就有人想到了二战时这架元首的末日黑科技。结合二战飞翼布局的灵感和最新的科技成果——幽灵问世了。</p><p><img src="https://pic4.zhimg.com/50/v2-27e9597026d69e62ed32ce3490205436_hd.jpg" alt="img"></p><p>此时飞翼布局这个概念被重新拿出来，还真有一种“萧瑟秋风今又是，换了人间”的感觉，随着隐身技术的发展，人们在飞机上用的雷达吸波涂层和隐身气动外形设计上已经取得了长足的进步，飞机要实现隐身可以不再依赖木头，也不再非要用117那样棱角分明的外形。</p><p>想要了解吸波材料的伙伴们可以看看这篇综述的引言，大致上有个了解：</p><p><img src="https://pic4.zhimg.com/50/v2-000b4f53ad0828b65a2c2ab3bbe97c19_hd.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/50/v2-57a0d4cf690054c9c651ed3ac126668f_hd.jpg" alt="img"></p><p>庞大的B2燃油足矣可以跨洲际打击，一个最大起飞重量在一百五十吨以上的大家伙在雷达上不过是一只鸟的面积，全得益于独特的隐身细节处理：</p><p>B2的机身采用严格的平行锯齿化设计，雷达波打上来只会反射到两个预定的方向（安全区），发动机进气口尾喷口采用隐身化处理，进气道采用S型遮挡了雷达反射重灾区之一的发动机叶片，这个大家伙没有尾翼，只能靠机尾的偏流板小幅度的偏转来实现飞行方向的控制。</p><p><img src="https://pic4.zhimg.com/50/v2-db0ed1ebb7aec047d584efa1d04f8e59_hd.jpg" alt="img"></p><p>这种处女座设计师搞出来的轰炸机，如果真要挑出一点缺点的话，那大概就是贵吧……</p>]]></content>
      
      
      <categories>
          
          <category> 知乎收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知乎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知乎收藏·如果有一个以召唤化学元素战斗的世界会是怎样？</title>
      <link href="/2019/%E7%9F%A5%E4%B9%8E%E6%94%B6%E8%97%8F%C2%B7%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%8F%AC%E5%94%A4%E5%8C%96%E5%AD%A6%E5%85%83%E7%B4%A0%E6%88%98%E6%96%97%E7%9A%84%E4%B8%96%E7%95%8C%E4%BC%9A%E6%98%AF%E6%80%8E%E6%A0%B7%EF%BC%9F/"/>
      <url>/2019/%E7%9F%A5%E4%B9%8E%E6%94%B6%E8%97%8F%C2%B7%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%8F%AC%E5%94%A4%E5%8C%96%E5%AD%A6%E5%85%83%E7%B4%A0%E6%88%98%E6%96%97%E7%9A%84%E4%B8%96%E7%95%8C%E4%BC%9A%E6%98%AF%E6%80%8E%E6%A0%B7%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p> 原链接：<a href="https://www.zhihu.com/question/313704885/answer/622025714" target="_blank" rel="noopener">如果有一个以召唤化学元素战斗的世界会是怎样？ - 孙亚飞的回答 - 知乎</a></p><p>首先，请允许我盛赞一下本次的“元素之旅”圆桌活动，因为除了一些知识性的问题以外，问了好多脑洞型的问题，这比那些搜索一下就能解答的问题更需要动脑筋！所以，我来个硬核的！</p><p>召唤元素用于战斗，对于一个常年在化学实验室的人来说，第一个需要考虑的问题是安全性，万一召唤来的武器是敌我不分的怎么办？别笑，这种事没少发生过。化学武器的前身其实就是一些有毒的烟，通过燃烧一些植物来实现对敌人的麻痹，但这是以风媒传播，所以最大的麻烦就是，“东风不与周郎便”，风向一旦反过来，那就是毒死自己人了。我记得《武状元苏乞儿》里也用了这个桥段。</p><p>所以，从这个角度来说，单纯的气体不能用于召唤，对自己的危险系数太大。</p><p>第二个问题，如果一种武器召唤来了之后，我方无法防御，又该怎么办？所以，这又是另外一个难题了，不解决好防御问题，进攻的风险太大。</p><p>最后还需要考虑的一点，万一对手有很强的克制武器，我们有没有更好的招数反克制？</p><p>除此以外，我们还得确定个游戏规则，既然我们能召唤，那么对方也能够召唤。召唤总要有个限制，那我们不妨就以回合制，一次就只能召唤出一张手牌，呸，一种元素，然后开始参与战斗，看看怎么选择的胜率最大。</p><h3 id="第一回合选择："><a href="#第一回合选择：" class="headerlink" title="第一回合选择："></a>第一回合选择：</h3><p>以防御为主。只有一个元素，那么攻击无非是物理攻击、化学攻击和放射性攻击。首先要考虑防住放射线，很多重核原子都可以做到，既然是不差钱，那么包括金、铂在内的贵金属也都可以选。经典的防御性元素当然是铅，但是铅对化学的防御性不是特别强，硫磺都顶不住，而且熔点也太低，万一对手召唤第二个元素的时候引发了灼热攻势，很可能扛不住。但是，贵金属也有一点不合适，化学太过惰性，除了防御性强之外，对己方也不利。综合对比下来，钨应该是首回合最值得召唤的，既能够顶住放射线，密度又大，熔点也高，一般的物理攻击也无效；化学上也算惰性，至少一个回合就绝杀钨的可能性不大。但是反过来，要是对手选的是铁这种货色，以钨弹物理攻击，就足以破防了，一举多得。</p><h3 id="第二回合选择："><a href="#第二回合选择：" class="headerlink" title="第二回合选择："></a>第二回合选择：</h3><p>如果首回合不分胜负，那我们第二个选择，就要做好更多的应对，实现更多的可能性，那么，化学性质的多样性，这一轮是一定要考虑的，同时，对手已经知道我们手上有钨作为防御了，肯定也会设法攻破。不过不必担心，即使有两种元素，哪怕是氟化氢，想要突破我们这道用钨搭出来的防线，还是不太容易。实际上，要想把钨腐蚀透，一般需要四种元素，也就是王水，或者氢氟酸加硝酸的组合，这是比王水更可怕的玩意儿，它们都是四种元素。</p><p>但是，钨导电啊，这一点有些不利，要是对手做出来原电池了，用强电流攻击，好像也挺危险的，防不住啊。或者制造个物理磁场，然后切割磁感应线，它还能搞出个交流电。甭管直流交流了，总之都挺危险的。我料定，对手只用两个元素似乎搞不出这么多道道儿，但是三种元素，就足以制造原电池了。总之，危险！</p><p>综上考虑，我们这一回合应该要加个碳。</p><p>碳有什么好处呢？一是它可以制造的物质多，二是，它可以和钨组合成碳化钨啊！碳化钨合金，也有叫陶瓷的，化学式WC，通常用作特种合金，但是个绝缘体，多合适啊。</p><h3 id="第三回合选择："><a href="#第三回合选择：" class="headerlink" title="第三回合选择："></a>第三回合选择：</h3><p>目前我们能够制造的攻击只有两种，一是拿钨弹砸对手，二是拿金刚石砸对手，至于石墨，真的会有伤害吗？</p><p>总之，太弱！接下来，就该增加攻击性了。</p><p>不用分析太多，直接上氮元素。</p><p>它的好处有三点，一是可以和碳构成一个基本的化学攻击武器(CN)2，也就是氰气，我们已经有很强的堡垒了，可以扔毒气了；二是它可以接着点下一个技能点，炸药；三是它和碳都是有机物的重要组成部分，为后续增强埋下伏笔。</p><h3 id="第四回合选择："><a href="#第四回合选择：" class="headerlink" title="第四回合选择："></a>第四回合选择：</h3><p>注意，我们前面已经分析，有了四个元素，钨就可能被化学腐蚀，不仅如此，碳化钨也有这个可能性，是不是很慌？</p><p>别怕，我们有碳啊，这时候再召唤一个，氟元素。有了氟，我们可以造出全氟有机物，比如聚四氟乙烯，它的外号塑料王，任你什么氢氟酸，什么王水，都无济于事，把它涂在钨的外层，对手也无可奈何。</p><h3 id="第五回合选择："><a href="#第五回合选择：" class="headerlink" title="第五回合选择："></a>第五回合选择：</h3><p>我们的攻击性现在除了物理攻击，还有一些化学毒气，尤其是氟气，那还是相当凶悍的。但是，氟元素，对手在前四次选择中，八成也会选，而氟就是氟的最大克星，所以，不能太过指望它，还得考虑下一步。</p><p>这一次的选择其实就要多样化一些了。</p><p>比如我们可以造炸药。有人说，这只能选氧了，要不然没有氧化剂，咋爆？嘿，我只能说此言差矣，叠氮酸盐不可以吗？随便有个强还原性的元素就可以了。</p><p>当然，从综合的角度来说，氢和氧，在这一回合总应该要选一个了，这俩还是太有价值了。优先选氢。</p><h3 id="第六回合选择："><a href="#第六回合选择：" class="headerlink" title="第六回合选择："></a>第六回合选择：</h3><p>这一轮我们就把氧选了吧。</p><p>总的来说，前面这六轮，不管敌方怎么选，我方应当是能够保持不败的，而且也已经凑够了碳氢氧氮，也就是说，最基本的生物武器也可以开始预备了。</p><p>炸药和毒气已经可以造出来不少了，所以没必要在这方面继续下什么功夫，而要考虑一些新的技术。那么接下来我们该怎么办呢？</p><h3 id="第七回合选择："><a href="#第七回合选择：" class="headerlink" title="第七回合选择："></a>第七回合选择：</h3><p>如果前六个选择，对手和我们基本一样，那就是最可怕的结果了，这时候我们需要做的是跳出一般的武器升级思路。</p><p>比较值得考虑的是制导技术，因为对手已经藏得很好了，我们需要做的就是瞄准它的最薄弱处。同时，我们还要建立数字干扰技术，防止对手以同样的方式打过来（我真是精神分裂）。综合考虑，半导体技术是这个时候必须发展的，造出芯片很重要，应当选择硅或者锗，硅可能更好一些。</p><h3 id="第八回合选择："><a href="#第八回合选择：" class="headerlink" title="第八回合选择："></a>第八回合选择：</h3><p>钛！</p><p>第七轮都有了制导武器还没用，那我们得造出点飞行器强攻了，不管是载人还是无人的。有人会想到铝，但是对于战斗机来说，钛更合适。美国曾经有过不少传奇的战机，特别是黑鸟侦察机，3马赫全钛机，连导弹都不能追上它。老美当年造不起，但现在我们不是能召唤元素了么，可劲儿造！</p><h3 id="第九回合选择："><a href="#第九回合选择：" class="headerlink" title="第九回合选择："></a>第九回合选择：</h3><p>此时再不选铁，更待何时？</p><p>铁也很重要，但是前面为了发展，我们只好耽搁了。铁是多用途元素，如果接下来不幸需要进行巷战，没有铁肯定是不行的。同时，我们不是还想搞细菌战什么的么，细菌最喜欢铁了，你看我们细菌性感冒发烧啥的，那就是细菌在体内跟我们的血液抢铁元素。所以，这个时候，我们已经迫不及待需要它了。</p><h3 id="第十回合选择："><a href="#第十回合选择：" class="headerlink" title="第十回合选择："></a>第十回合选择：</h3><p>为了凑够元素周期表十大武器，我也是实在编不下去了，一本正经地胡说八道还真是累。</p><p>不过，如果真的存在这样的一个世界，我希望第十个选择，不是一个真正的元素，而是和平。倒不是强行以情怀结尾，只是觉得，任何的战争都不是解决问题的方式，如果一场战争打了这么多回合，都已经考虑白刃战了，依然还是你死我活的状态，这真的是一件很残忍的事情。战争的终点是和平，不是为了杀人，否则，我们因何而战呢？</p><p>就是这样，感谢阅读。</p><p>如果有兴趣以<strong>元素召唤</strong>做卡牌手游的，我觉得我可以做个顾问，给不同的元素安上不同的技能，像三国杀似的不停摸牌，或者拼杀十个回合，好像也挺带感的？</p><p>另外，推荐我接下来会出的一本童话科普，《原子王国历险记》，其实就是我开的一个脑洞，想象原子之间的一场战争，加入了一些感情色彩，主要面向十来岁的孩子。不过，我相信，其实大多数成年人也未必看得懂……那个里面，我对各种元素的特性描述得更具体一些。此外，我还在策划创作一本战争元素的书，专门写人类史上战争升级中，对不同元素的使用，目前还没找到出版社签合同，争取今年能签约！请大家拭目以待。</p>]]></content>
      
      
      <categories>
          
          <category> 知乎收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知乎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知乎收藏·如果有一节永远有电的五号电池，能用来做什么？</title>
      <link href="/2019/%E7%9F%A5%E4%B9%8E%E6%94%B6%E8%97%8F%C2%B7%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E8%8A%82%E6%B0%B8%E8%BF%9C%E6%9C%89%E7%94%B5%E7%9A%84%E4%BA%94%E5%8F%B7%E7%94%B5%E6%B1%A0%EF%BC%8C%E8%83%BD%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2019/%E7%9F%A5%E4%B9%8E%E6%94%B6%E8%97%8F%C2%B7%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E8%8A%82%E6%B0%B8%E8%BF%9C%E6%9C%89%E7%94%B5%E7%9A%84%E4%BA%94%E5%8F%B7%E7%94%B5%E6%B1%A0%EF%BC%8C%E8%83%BD%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p> 原链接：<a href="https://www.zhihu.com/question/312752767/answer/607264132" target="_blank" rel="noopener">如果有一节永远有电的五号电池，能用来做什么？ - 不是时臣是石墨的回答 - 知乎</a></p><p>“大家好，今天我们要来到科学史的最关键的一章，请翻开课本到76页。其实这个部分不考，可能你们的历史课会考？但是无论如何，作为一个物理专业出身的人，我觉得有必要给你们讲一讲。”</p><p>“我们不知道是谁，在什么地方发现了那颗电池，我们也不清楚它为什么具有那样的性质，但是总之，它是一颗无法用现有物理手段破坏，而又会不断自我充电的电池。可是就像我们所知的所有电池一样它的功率是有限的，而且非常小。”</p><p>“可是工程学正是一门以小搏大的科学，工程师们很快意识到，如果把它埋进导电的介质里面——像是金属，盐水，或者等离子体——那么它就会不断地周期性地产生电流，进而在周围激发出微弱的磁场，使得我们可以用磁场从远距离加速它。我想你们应该见过化学实验室里的磁搅拌子：这就够了。这就是后来一切的开端。”</p><p>“最开始是在六十多年前，人们在太平洋底挖了一条极其长的隧道。在隧道的一端我们用一束高密度等离子气体带着那颗电池高速喷出来；我们通过计算，在它产生电流的时候在周围用磁场予以加速。当它的速度足够快的时候，就将一些装有氘和氚的容器扔到它的路径上。”</p><p>“这是人类史上最伟大的惯性约束聚变反应，一颗不可破坏的物体高速冲过空中一堆蠢蠢欲动的原子核，撞击接触面上的粒子被赋予粒子层面上的巨大动量，或者用个通俗说法，温度——于是，轰。巨大的能量在电池的背后爆发，隧道充满高温而躁动的等离子气体；我们将用古老的热机系统从那巨大的能量中攫取一部分。而那颗电池，它将完好无损地继续在一堆上千万摄氏度的等离子气体中向前笔直飞行，穿过更多的原子核，它可以被用加速同样的方式减速，就像磁铁被楞次定律减速那样。困扰人类上百年的可控核聚变难点在一夜之间变成了可解的工程学问题。”</p><p>“当然，最开始的时候我们很难控制这巨大的反应炉，那时候确实死了很多人——要不是那个老兄还有一个完整的肝脏，我也早就死了——但是我们已经不同于我小时候那个年代迷茫的科学家们了。只要知道这个技术问题是可解的，就只是付出多少时间和代价的问题了。我们在地球上先后建造了十多条隧道，终于设法把它稳定下来。”</p><p>“人类将小小的太阳握在掌心，于是万物茁壮成长——这就是你们之所以被称作【阿波罗世代】的原因。”</p><p>“如今你们已经看不到那些隧道了，能源获取在地质结构更稳定的土星上进行。我们现在上课的课堂是位于欧亚大陆的第三代聚变电厂——当然，从二十年前开始它就是居民区了。在二十五年前，我终于不得不从那里退休的时候，那颗小小的电池带来的庞大能源几乎解决了当时所有的社会问题。我们的化学和生物医学研究飞速发展，我们的月面基地拔地而起，我们抛弃笨重的工质火箭转而选择反物质电池，在几十年内就抵达了太阳系的每个角落，不久的将来也许我们可以抵达别的星系。”</p><p>“我知道你们在担心什么，如果那颗电池突然失去了它的性质，那我们该怎么办？事实上，这个问题在几十年前就有人提出过了，我们也深知，全人类只有这一个炉芯是不够用的——这也就是为什么戴森球计划正在实行，小行星带的聚变炉也在建造中，即使下一秒钟那颗不灭的炉芯突然消失，我们也可以继续过我们的日子。永远不要小看人类的韧性，我还活着呢，不是么？”</p><p>“如果那颗无限电量却只能点亮一个灯泡的电池是神尝试嘲讽人类的一个玩笑，那么我选择用一部老电影里面的台词来回答祂：救赎就在其中。”</p><p><strong>“是的，乌托邦就是这么简单：一点点永恒不灭的物质，加上一个永不言弃的文明。”</strong></p>]]></content>
      
      
      <categories>
          
          <category> 知乎收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知乎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX数学符号大全</title>
      <link href="/2019/LaTeX%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E5%A4%A7%E5%85%A8/"/>
      <url>/2019/LaTeX%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="LaTeX数学符号大全"><a href="#LaTeX数学符号大全" class="headerlink" title="LaTeX数学符号大全"></a>LaTeX数学符号大全</h1><ol><li><p>指数和下标可以用<code>^</code>和<code>_</code>后加相应字符来实现。比如：<img src="https://i.loli.net/2019/10/30/und27kqb1xtALFz.gif" alt="foot.gif"></p></li><li><p>平方根（square root）的输入命令为：<code>\sqrt</code>，n 次方根相应地为: <code>\sqrt[n]</code>。方根符号的大小由LATEX自动加以调整。也可用 <code>\surd</code> 仅给出符号。比如：<img src="https://i.loli.net/2019/10/30/91l45h8QjEF3w2C.gif" alt="sqrt.gif"></p></li><li><p>命令<code>\overline</code> 和<code>\underline</code> 在表达式的上、下方画出水平线。比如：<img src="https://i.loli.net/2019/10/30/HNnBKeDAxgSwPrl.gif" alt="overline.gif"></p></li><li><p>命令<code>\overbrace</code> 和<code>\underbrace</code> 在表达式的上、下方给出一水平的大括号。</p></li></ol><p><img src="https://i.loli.net/2019/10/30/b6JKZgCIQvFG8mT.gif" alt="brace.gif"></p><ol start="5"><li><p>向量（Vectors）通常用上方有小箭头（arrow symbols）的变量表示。这可由<code>\vec</code> 得到。另两个命令<code>\overrightarrow</code> 和<code>\overleftarrow</code>在定义从 A 到 B 的向量时非常有用。<img src="https://i.loli.net/2019/10/30/7jOPVtGMvwUyWbJ.gif" alt="vec.gif"></p></li><li><p>分数（fraction）使用<code>\frac{...}{...}</code> 排版。一般来说，1/2 这种形式更受欢迎，因为对于少量的分式，它看起来更好些。<img src="https://i.loli.net/2019/10/30/39s4NRlLm2QZwgo.gif" alt="frac.gif"></p></li><li><p>积分运算符（integral operator）用<code>\int</code> 来生成。求和运算符（sum operator）由<code>\sum</code> 生成。乘积运算符（product operator）由<code>\prod</code> 生成。上限和下限用<code>^</code>和<code>_</code>来生成，类似于上标和下标。<img src="https://i.loli.net/2019/10/30/XtVkU5iz1oHOCeA.gif" alt="int.gif"></p></li></ol><p><strong><em>以下提供一些常用符号的表示方法:</em></strong></p><p><img src="https://i.loli.net/2019/10/30/Hg3fmMRDnCLkoTs.gif" alt="1.gif"></p><p><img src="https://i.loli.net/2019/10/30/n89EpFRmP6hajOf.gif" alt="2.gif"></p><p><img src="https://i.loli.net/2019/10/30/EqiZQWfcHt5S2PK.gif" alt="3.gif"></p><p><img src="https://i.loli.net/2019/10/30/78wT6yejgLkYOnC.gif" alt="4.gif"></p><p><img src="https://i.loli.net/2019/10/30/16jftM4VgUBJDWI.gif" alt="5.gif"></p><p><img src="https://i.loli.net/2019/10/30/qdmFNI43nSAB8l6.gif" alt="6.gif"></p><p><img src="https://i.loli.net/2019/10/30/jQZa9g1zODEnH6x.gif" alt="7.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P1195 【口袋的天空】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-P1195-%E3%80%90%E5%8F%A3%E8%A2%8B%E7%9A%84%E5%A4%A9%E7%A9%BA%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-P1195-%E3%80%90%E5%8F%A3%E8%A2%8B%E7%9A%84%E5%A4%A9%E7%A9%BA%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="P1195-题解"><a href="#P1195-题解" class="headerlink" title="P1195 题解"></a>P1195 题解</h1><p>其实这是一道很不错的题，有助于加深对Kruskal算法的理解，十分推荐</p><hr><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>先放几个定义：</p><ol><li>子图：对于$\forall G_1=(V_{G_1},E_{G_1})$，有$V_{G_1}\in V_G \land E_{G_1}\in E_G$,则$G_1$是$G$的子图。</li><li>连通块： 若$G_1$是$G$的子图，且$G_1$连通，则$G_1$是$G$的连通块。</li><li>无环连通块：若$G_1$是$G$的连通块，且$G_1$中不含有环，则则$G_1$是$G$的无环连通块。</li></ol><p><strong>题目大意：求使用边集中的边，将$n$个孤立的点连成$k$个连通块所需的最小边权和。</strong></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，如果想要边权和最小，所有的连通块都应该是<strong>无环连通块</strong>。原理很简单：如果连通块中有环的话，则一定可以删去一条边使边权和变小。因此，我们很容易想到用<strong>Kruskal</strong>算法解决。</p><h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><p>由Kruskal算法的步骤我们可以得出以下性质：</p><p><strong>在一个图中保留$n-k$条边，则图中至多有$k$个无环连通块。</strong></p><h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><p><em>首先，当k=1时，命题显然成立（此时图中唯一的无环连通块是图的<strong>生成树</strong>）</em></p><p><em>接下来，设k=a时命题成立(即连通块有a个），则k=a+1时，因为边数减少了一条，则原图中一定有一个无环连通块失去了一条边。又因为无环连通块的无环性，无环连通块中的每一条边都是桥。因此这条边的失去一定会使原无环连通块分裂为两个更小的无环连通块，因此总的连通块个数增加1，变为a+1,命题成立。</em></p><p><em>因此，由数学归纳法可得，原命题成立。</em></p><p><em>证毕</em>。</p><p>接下来，解题的思路便已经很明朗了：<strong>直接使用Kruskal算法，将选$n-1$条边后停止变为$n-k$条边后停止</strong>。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="comment">//边</span></span><br><span class="line"><span class="keyword">int</span> f=<span class="number">0</span>,t=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">edge(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c) : f(a),t(b),w(c) &#123;&#125;</span><br><span class="line">edge() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span> <span class="comment">//比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(edge a,edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">edge e[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> Count=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">//初始化并查集</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="comment">//"找爹"</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[v]==v) <span class="keyword">return</span> f[v];</span><br><span class="line">f[v]=getf(f[v]);</span><br><span class="line"><span class="keyword">return</span> f[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> <span class="comment">//合并,同时判断是否成功</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=getf(a);</span><br><span class="line"><span class="keyword">int</span> y=getf(b);</span><br><span class="line"><span class="keyword">if</span>(x!=y)</span><br><span class="line">&#123;</span><br><span class="line">f[x]=y;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;e[i].f&gt;&gt;e[i].t&gt;&gt;e[i].w;</span><br><span class="line">&#125;</span><br><span class="line">sort(e+<span class="number">1</span>,e+m+<span class="number">1</span>,cmp()); <span class="comment">//将边按照权值排序</span></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">if</span>(m&lt;n-k) <span class="comment">//如果不够n-k条边</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"No Answer"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(merge(e[i].f,e[i].t)) <span class="comment">//如果能够合并就选，同时合并</span></span><br><span class="line">&#123;</span><br><span class="line">++Count; <span class="comment">//选边</span></span><br><span class="line">ans+=e[i].w; <span class="comment">//累加答案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Count==n-k) <span class="keyword">break</span>; <span class="comment">//如果选够n-k条边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出答案</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】并査集</title>
      <link href="/2019/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B6%E6%9F%BB%E9%9B%86/"/>
      <url>/2019/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B6%E6%9F%BB%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并査集"><a href="#并査集" class="headerlink" title="并査集"></a>并査集</h1><p><strong>并査集</strong>是一个用于维护<strong>不相交集合（Disjoint Set)</strong>的数据结构。其本质是对每一个元素选定一个“代表元”，且相同集合中元素的“代表元”相同（这个集合的“代表元”就是其中每个节点的代表元）。</p><p>注意：这个字读<strong>chá</strong>$!!!$</p><p>并査集可以用于维护具有<strong>传递性</strong>的信息，一个典型的例子是相等关系(若$a=b$，$b=c$,则$a=c$)（$ps$：恋爱关系很明显不具有传递性$\dots$)</p><hr><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>算法竞赛领域的“并査集”一般指<strong>树形并查集</strong>（并查集的实现还有一种链表形式，但效率非常低下，所以一般不使用）</p><p>树形并查集的结构是一个<strong>森林</strong>，<strong>每棵树代表一个集合</strong>，其<strong>树根</strong>就是“代表元”，其结构如图所示：</p><p><img src="https://i.loli.net/2019/11/02/12t49VXGqTa85oL.png" alt="并查集演示.png"></p><p>（图中1,2,3号节点构成一个代表元为1的集合，4号节点构成一个代表元为4的集合，5,6,7,8号节点构成一个代表元为5的集合）</p><p>由此可以看出，这种并查集的实现只要找到树根就可以判断两个元素是否在一个集合中，效率很高。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>并查集的功能通过两个基本操作来实现，即“找根”和“合并”：</p><h3 id="找根"><a href="#找根" class="headerlink" title="找根"></a>找根</h3><p>首先我们需要存储每个节点的父节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[maxn] <span class="comment">//x的父节点为fa[x]</span></span><br></pre></td></tr></table></figure><p>接下来，对于每个节点，我们只需要<strong>沿着“父节点”不断向上寻找，直到找到父节点是自身的节点</strong>（<strong>树根</strong>）</p><p><img src="https://i.loli.net/2019/11/02/1w73FBHV2UMfvxS.png" alt="找根.png"></p><p>比如说对4号节点进行“找根”，因为4号节点的父节点是2号节点，再对2号节点进行“找根”，依此类推。直到找到1号节点，因为1号节点的父节点指向自身，因此可以判定1号节点是树根，即4号的“代表元”。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[v]==v) <span class="keyword">return</span> v; <span class="comment">//如果是根节点，返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> getf(f[v]); <span class="comment">//否则找根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>因为每个集合都由一个“代表元”（树根）指定，所以只要<strong>简单地合并两个集合的“代表元”（使一个“代表元”成为另一个“代表元”的子节点）</strong>，就可以合并两个集合。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=getf(a); <span class="comment">//a的“代表元”</span></span><br><span class="line">    <span class="keyword">int</span> y=getf(b); <span class="comment">//b的“代表元”</span></span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span>; <span class="comment">//a与b在同一个集合中</span></span><br><span class="line">    f[x]=y; <span class="comment">//合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>使用上面方式实现的并查集已经可以实现其功能了，但是还存在一个问题：</p><p><img src="https://i.loli.net/2019/12/08/lCKevRDrWUafHkb.png" alt></p><p>如果并查集被合并成像上图一样的链式结构，那么对n号节点</p>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/hello-world/"/>
      <url>/2019/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GDB简单实用教程</title>
      <link href="/2019/GDB%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2019/GDB%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="GDB简单实用教程"><a href="#GDB简单实用教程" class="headerlink" title="GDB简单实用教程"></a>GDB简单实用教程</h1><p><strong>GDB</strong>是G++附带的调试工具，提供了设置断点、打印变量、单步调试等功能，可以让你在调试程序时事半功倍…</p><p>GDB可以</p><ol><li>启动你的程序，可以按照你的定制要求随心所欲的运行程序。 </li><li>可让被调试的程序在你所指定的调置的断点处停住。 </li><li>当程序被停住时，可以检查此时你的程序中所发生的事，以及内存状态等。 </li><li>动态的改变你程序的执行环境。</li></ol><p>当然，GDB不是这个东西：<br><img src="https://i.loli.net/2019/09/08/oMO32A6j5CX8rvS.png" alt="TIM截图20190908113017.png"></p><p>(图形化的GDB缺少一些必要的回显，例如函数中断点不会显示当前函数名和参数，有些时候很麻烦)。。。</p><h2 id="Windows下GDB使用"><a href="#Windows下GDB使用" class="headerlink" title="Windows下GDB使用"></a>Windows下GDB使用</h2><p>一般情况下GDB在Windows系统下会在MinGW或MinGW64文件夹下的bin目录中，如图：</p><p><img src="https://i.loli.net/2019/09/08/HDFPnO5xceVuiYA.png" alt="TIM截图20190908113710.png"></p><p>双击即可开始运行，如果你想要用命令也可以<code>cd</code>到这个目录然后<code>.\gdb</code></p><p><img src="https://i.loli.net/2019/09/08/7VGX1dITkZofjgS.png" alt="TIM截图20190908114132.png"></p><p>(注：笔者使用的是CMDer，与普通CMD效果可能略有出入)</p><p><strong>GDB使用的前置条件是你的程序在编译时包含了调试信息</strong>，如果你在使用命令行编译，那么请在指令的后面加入<code>-g</code>;如果你在使用IDE的话，也需要将IDE中的编译指令加入<code>-g</code>,如果你的IDE中有默认的“Debug”属性的话，那么用默认的就行：</p><p><img src="https://i.loli.net/2019/09/08/zCpjK3eUSEPT7L1.png" alt="TIM截图20190908115335.png"></p><p>在加入<code>-g</code>时，值得注意的时<code>-g</code>一共有4个等级：</p><ul><li><code>-g0</code>等于不加-g。即不包含任何信息</li><li><code>-g1</code>只包含最小信息，一般来说只有你不需要debug，只需要backtrace信息，并且真的很在意程序大小，或者有其他保密/特殊需求时才会使用-g1。</li><li><code>-g2</code>为gdb默认等级，包含绝大多数你需要的信息。</li><li><code>-g3</code>包含一些额外信息，例如包含宏定义信息。当你需要调试宏定义时，请使用-g3</li></ul><p>进入gdb后，输入<code>file {你的程序}</code>。然后使用<code>set args  {arg1} {arg2} … {argN}</code> 设定好你的程序参数，再运行<code>run</code>.</p><p><img src="https://i.loli.net/2019/09/08/7L1mTvb3OpEayiF.png" alt="TIM截图20190908121133.png"></p><h2 id="GDB指令"><a href="#GDB指令" class="headerlink" title="GDB指令"></a>GDB指令</h2><p><strong>help指令很强大！多用help！help里面总会有你需要的信息。如果你不知道如何使用help，请在gdb里面输入：<code>help all</code></strong></p><p>这里挑选一些常用的指令给大家说明一下：（指令需要在控制权在GDB下时（如遇到断点）</p><ol><li><p><code>backtrace</code>显示栈信息。简写为<code>bt</code>;</p></li><li><p><code>frame x</code> 切换到栈的第x层。其中x会在<code>bt</code>命令中显示，从0开始。0表示栈顶。简写为<code>f</code>;</p></li><li><p><code>up/down x</code> 往栈顶/栈底移动x帧。当不输入x时，默认为1;</p></li><li><p><code>print x</code>打印x的信息，x可以是变量，也可以是对象或者数组。简写为<code>p</code>;</p></li><li><p><code>print */&amp;x</code> 打印x的内容/地址(就相当于C++的<code>*</code>和<code>&amp;</code>运算符);</p></li><li><p><code>call</code> 调用函数。注意此命令需要一个正在运行的程序;</p></li><li><p><code>break x</code>在的第x行设置断点，然后gdb会给出断点编号y。简写为<code>b</code>。后面会对断点进行更详细的解释;</p></li><li><p><code>command m</code> 设置程序执行到断点m时要看的内容，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">command n</span><br><span class="line"></span><br><span class="line">&gt;printf &quot;x is %d\n&quot;,x</span><br><span class="line"></span><br><span class="line">&gt;c</span><br><span class="line"></span><br><span class="line">&gt;end</span><br></pre></td></tr></table></figure><p>如果command后面没有参数n，则命令被赋给最后一个breakpoint，这其实是说break和command连在一起用，在脚本里用就非常方便了;</p></li><li><p><code>continue</code> 继续运行程序。进入调试模式后，若你已经获取了你需要的信息或者需要程序继续运行时使用。可简写为<code>c</code></p></li><li><p><code>until</code> 执行到当前循环完成。可简写为<code>u</code>;</p></li><li><p><code>step</code> 单步调试，步入当前函数。可简写为<code>s</code>;</p></li><li><p><code>next</code>单步调试，步过当前函数。可简写为<code>n</code>;</p></li><li><p><code>finish</code> 执行到当前函数返回;</p></li><li><p><code>set var x=10</code> 改变当前变量x的值。也可以这样用：set {int}0x83040 = 10把内存地址0x83040的值强制转换为int并赋值为10(慎用);</p></li><li><p><code>info locals</code> 打印当前栈帧的本地变量;</p></li><li><p><code>jump</code>使当前执行的程序跳转到某一行;</p></li><li><p><code>return</code> 强制函数返回。可以指定返回值;</p></li><li><p><code>display x</code> 设置对表达式的展示，表达式x的值将在每次控制权转移到GDB下时打印一次;</p></li><li><p><code>delete y</code> 删除编号为y的断点，简写为<code>d</code>;</p></li></ol><h2 id="GDB点位："><a href="#GDB点位：" class="headerlink" title="GDB点位："></a>GDB点位：</h2><ol><li><p><strong>监视点(watchpoint)</strong>。监视点是监视内存中某个地址，当该地址的数据被改变（或者被读取）时，程序交出控制权进入调试器。注意监视点分为软件模式和硬件模式：GDB 使用软件监视点的方式是在单步执行你的程序的同时测试变量的值，所以执行程序的速度会变慢。同时，软件监视点仅在当前线程有效。幸运的是，32 位的 Intel x86 处理器提供了 4 个特殊的调试寄存器用来方便调试程序，GDB 可以使用这些寄存器建立硬件监视点。GDB 总是会优先使用硬件监视点，因为这样不会减慢程序的执行速度。然而，可用的（enable的）硬件监视点的个数是有限的。如果你设置了过多的硬件监视点，当程序从中断的状态变为执行的状态（例如continue，until或者finish）时，GDB 可能无法把它们全部激活。另外，活动的硬件监视点的数量只有在试图继续执行程序时才能知道，也就是说，即使你设置了过多的硬件监视点，gdb在你运行程序之前也不会警告你。</p><p>   设置监视点的命令有3个:</p><ul><li><p>watch（写监视）</p></li><li><p>rwatch（读监视）</p></li><li><p>awatch（读写监视）</p><p>他们的使用方法一样，皆为以下几种：</p></li></ul><ol><li><p>(r/a)watch x x是一个变量名。当x的值改变/被读取时，程序交出控制权进入调试器。</p></li><li><p>(r/a)watch 0xN N为一个有效地址。当该地址的内容变化/被读取时，程序交出控制权进入调试器。</p></li><li><p>(r/a)watch *(int *)0xN N为一个有效地址。当该地址的中的int指针指向的内容变化/被读取时，程序交出控制权进入调试器。</p></li><li><p>(r/a)watch -l *(int *)0xN N为一个有效地址。当该地址的中的int指针指向的内容变化/被读取，或者该地址的内容变化/被读取时，程序交出控制权进入调试器。</p><p>注意3和4的区别在于，当加入-l选项后，会同时监视表达式本身以及表达式指向的内容。</p></li></ol></li><li><p><strong>断点(breakpoint)</strong>。 断点是指当执行到程序某一步时，程序交出控制权进入调试器。值得注意的是，break会有一些变体：tbreak，hbreak，thbreak与rbreak。tbreak与break功能相同，只是所设置的断点在触发一次后自动删除。hbreak是一个硬件断点。thbreak则既是一个临时的硬件断点。注意硬件断点需要硬件支持，某些硬件可能不支持这种类型的断点。rbreak稍微特殊一些，它会在匹配正则表达式的全部位置加上断点。break家族的使用方法如下：</p><ol><li><p>(t/h)break x.cpp:y 。在代码x.cpp的第y行加入断点。x.cpp若不指定，则会以当前执行的文件作为断点文件。若程序未执行，则以包含main函数的源代码文件作为断点文件。若x.cpp和y都不指定，则以当前debugger的点作为断点处。</p></li><li><p>(t/h)break 0xN。在地址N处加入断点。N必须为一个有效的代码段（code segment）地址。</p></li><li><p>(t/h)break  x.cpp:func。在x.cpp的func函数入口处加入断点。x.cpp可以不提供直接使用break func。注意由于重载(overload)的存在，因此gdb可能会询问你希望在哪个函数加上断点。你也可以通过指定参数类型来避免该问题，例如break func(int ,char *)</p></li><li><p>(t/h)break  +/-N。在当前运行处的第N行后/前加入断点。</p></li><li><p>rbreak REGEXP。 在所有符合正则表达式REGEXP的函数入口加入断点。例如rbeak EX_* 表示在所有符合以EX_开头的函数入口处加入断点。</p><p>注意break后面还有2个可选参数，线程id和条件。线程id指在info threads中的线程序号，而非系统提供的tid。例如break x.cpp:y 2 if (a==24)，表示在2号线程的x.cpp的第y行加入断点，并且只有当a的值为24时，程序才会交出控制权进入调试器。</p><p>另外，breakpoints可以通过save命令保存，以方便使用者下次再次进入程序调试时不需要重设断点。</p></li></ol></li><li><p><strong>捕捉点(catchpoint)</strong>。捕捉点是当某些事件发生时，程序交出控制权进入调试器。例如catch一个exception，assert，signal，fork甚至syscall。tcatch与catch功能一样，只是所设置的捕捉点在触发一次后自动删除。</p></li><li><p><strong>跟踪点(tracepoint)</strong>。跟踪点与上面三个断点不同之处在于，它只是跟踪记录信息而不会中断程序的运行。当你的程序是realtime程序（如GUI），或者与其他的程序有交互时，你可能会希望使用跟踪点达到监视程序而又不破坏程序自身行为的目的。与断点相同的是，跟踪点会保存下在跟踪点时的一些内存信息供使用者查阅，例如数组或者对象。</p><p> 另外，tracepoints可以通过save命令保存，以方便使用者下次再次进入程序调试时不需要重设这些跟踪点。</p></li><li><p><strong>检查点(checkpoint)</strong>：</p><p>gdb可以保存某一个时间点的程序状态或者说是程序映像，并且稍后又可以返回到这个状态。这个称之为checkpoint(就如同你玩游戏时的检查点。。。)。</p><p>每个检查点是进程的一个拷贝。这样当一个bug很难重现，而又担心调试过头了又要从头开始重现时，可以在估计要重现这个bug之前，做一个checkpoint，这样即使debug过头了，也可以从这个checkpoint开始，而不用重启整个程序并且期待它重现这个bug（也许需要很久！！）。</p><p>但是每个checkpoint有一个唯一的进程id，这个pid与原始程序的pid不同，因此如果程序需要使用pid的信息时，需要慎重考虑。</p></li></ol><p><strong>如果你觉得这篇教程很好的话，请将其分享出去！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P2146 【[NOI2015]软件包管理器】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-P2146-%E3%80%90-NOI2015-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-P2146-%E3%80%90-NOI2015-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="P2146-题解"><a href="#P2146-题解" class="headerlink" title="P2146 题解"></a>P2146 题解</h1><p><a href="https://listener1379.site/2019/【算法笔记】树链剖分/">关于树链剖分的教程</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题就是一道<strong>树链剖分</strong>的模板题，用0和1分别代表每个软件的存在与否，那么“安装$k$”操作就是把从$1$到$k$的路径上的节点都置为$1$，而“卸载$k$”则是将$k$的子树都置为$0$，用树链剖分就可以十分方便地维护这两种操作。</p><p>然后对根节点求区间和就可以求出一共有多少个状态值为$1$（即安装了）的软件，用这个数减去上一次操作时的安装软件数即为改变的数目。</p><hr><h2 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h2><ul><li>“赋值”运算不能进行叠加，打延迟标记时要注意<strong>先将原有的延迟标记下传</strong></li><li>数据范围这么大一定要写<strong>快读</strong></li></ul><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,last;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[maxn];</span><br><span class="line"><span class="keyword">int</span> father[maxn],dep[maxn],size[maxn],hson[maxn],top[maxn],seg[maxn],rev[maxn&lt;&lt;<span class="number">2</span>],num[maxn],tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segmenttree</span>&#123;</span> <span class="comment">//线段树</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum,add=<span class="number">-1</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> add(x) tree[x].add</span></span><br><span class="line">&#125;;</span><br><span class="line">segmenttree tree[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">readint</span><span class="params">()</span> </span>&#123; <span class="comment">//快读</span></span><br><span class="line">   <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) x=x*<span class="number">10</span>+ch<span class="number">-48</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readchar</span><span class="params">(<span class="keyword">char</span> * input)</span> </span>&#123; <span class="comment">//快读</span></span><br><span class="line">  <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> ch=getchar();</span><br><span class="line">  <span class="keyword">while</span>(ch!=<span class="string">' '</span> &amp;&amp; ch!=<span class="string">'\r'</span> &amp;&amp; ch !=<span class="string">'\n'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    input[len++]=ch;</span><br><span class="line">    ch=getchar();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="comment">//vector存图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[x].push_back(y);</span><br><span class="line">    e[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> <span class="comment">//树剖预处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[u]=<span class="number">1</span>;</span><br><span class="line">    father[u]=f;</span><br><span class="line">    dep[u]=dep[f]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[u].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v!=f)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs1(v,u);</span><br><span class="line">            size[u]+=size[v];</span><br><span class="line">            <span class="keyword">if</span>(size[v]&gt;size[hson[u]]) hson[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> <span class="comment">//树剖预处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hson[u])</span><br><span class="line">    &#123;</span><br><span class="line">        seg[hson[u]]=++tot;</span><br><span class="line">        top[hson[u]]=top[u];</span><br><span class="line">        rev[tot]=hson[u];</span><br><span class="line">        dfs2(hson[u],u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[u].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!top[v])</span><br><span class="line">        &#123;</span><br><span class="line">            seg[v]=++tot;</span><br><span class="line">            rev[tot]=v;</span><br><span class="line">            top[v]=v;</span><br><span class="line">            dfs2(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> <span class="comment">//线段树建树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    l(p)=l;r(p)=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        sum(p)=num[rev[l]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    build(p&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    build(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    sum(p)=(sum(p&lt;&lt;<span class="number">1</span>)+sum(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="comment">//下传延迟标记</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(add(p)&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum(p&lt;&lt;<span class="number">1</span>)=add(p)*(r(p&lt;&lt;<span class="number">1</span>)-l(p&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line">sum(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)=add(p)*(r(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)-l(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line">add(p&lt;&lt;<span class="number">1</span>)=add(p);</span><br><span class="line">add(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)=add(p);</span><br><span class="line">add(p)=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> <span class="comment">//区间查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) swap(l,r);</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=l(p) &amp;&amp; r&gt;=r(p)) <span class="keyword">return</span> sum(p);</span><br><span class="line">  spread(p);</span><br><span class="line">  <span class="keyword">int</span> mid=((l(p)+r(p))&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) ans=(ans+query(p&lt;&lt;<span class="number">1</span>,l,r));</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) ans=(ans+query(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123; <span class="comment">//区间更新</span></span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) swap(l,r);</span><br><span class="line">  spread(p); <span class="comment">//先将原有的延迟标记下传</span></span><br><span class="line">  <span class="keyword">if</span>(l&lt;=l(p) &amp;&amp; r&gt;=r(p)) &#123;</span><br><span class="line">sum(p)=c*(r(p)-l(p)+<span class="number">1</span>);</span><br><span class="line">add(p)=c;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=((l(p)+r(p))&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) update(p&lt;&lt;<span class="number">1</span>,l,r,c);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) update(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,c);</span><br><span class="line">sum(p)=(sum(p&lt;&lt;<span class="number">1</span>)+sum(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crange</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span> <span class="comment">//路径修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top[x]!=top[y]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">    update(<span class="number">1</span>,seg[top[x]],seg[x],k);</span><br><span class="line">    x=father[top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">  update(<span class="number">1</span>,seg[x],seg[y],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cson</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span> <span class="comment">//子树修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  update(<span class="number">1</span>,seg[x],seg[x]+size[x]<span class="number">-1</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  n=readint();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,a;i&lt;=n;i++)&#123;</span><br><span class="line">    a=readint();</span><br><span class="line">    addedge(i,a+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  m=readint();</span><br><span class="line">  dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  tot=seg[<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">//树剖初始化</span></span><br><span class="line">  top[<span class="number">1</span>]=rev[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  build(<span class="number">1</span>,<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> last=query(<span class="number">1</span>,<span class="number">1</span>,n); <span class="comment">//存好上一次的软件数</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=m;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s\n"</span>,op);</span><br><span class="line">    <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">'i'</span>) &#123; <span class="comment">//安装</span></span><br><span class="line">      x=readint();</span><br><span class="line">      crange(x+<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> cur=query(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">abs</span>(last-cur)); <span class="comment">//更新答案</span></span><br><span class="line">      last=query(<span class="number">1</span>,<span class="number">1</span>,n); <span class="comment">//存好上一次的软件数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">'u'</span>) &#123; <span class="comment">//安装</span></span><br><span class="line">      x=readint();</span><br><span class="line">      cson(x+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">int</span> cur=query(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">abs</span>(last-cur)); <span class="comment">//更新答案</span></span><br><span class="line">      last=cur; <span class="comment">//存好上一次的软件数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用EagleGet快速下载bilibili上的港澳台专属番剧</title>
      <link href="/2019/%E4%BD%BF%E7%94%A8EagleGet%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BDbilibili%E4%B8%8A%E7%9A%84%E6%B8%AF%E6%BE%B3%E5%8F%B0%E4%B8%93%E5%B1%9E%E7%95%AA%E5%89%A7/"/>
      <url>/2019/%E4%BD%BF%E7%94%A8EagleGet%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BDbilibili%E4%B8%8A%E7%9A%84%E6%B8%AF%E6%BE%B3%E5%8F%B0%E4%B8%93%E5%B1%9E%E7%95%AA%E5%89%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="使用EagleGet快速下载bilibili上的港澳台专属番剧"><a href="#使用EagleGet快速下载bilibili上的港澳台专属番剧" class="headerlink" title="使用EagleGet快速下载bilibili上的港澳台专属番剧"></a>使用EagleGet快速下载bilibili上的港澳台专属番剧</h1><p>众所周知，B站上有很多“港澳台专属”的番剧，比如<br><a href="https://www.kanjiantu.com/image/dvEQ38" target="_blank" rel="noopener"><img src="https://www.kanjiantu.com/images/2019/08/27/TIM20190827165832e1d0071ff60df52b.md.png" alt="TIM20190827165832e1d0071ff60df52b.md.png"></a></p><p>但是，这些福利满满<del>无圣光</del>的番剧因为众所周知的原因在大陆是无法观看的，而如果用梯子的话，你也会面临消耗过多流量以及网速慢的问题，而且<strong>B站的服务器位于国内</strong>，单纯为了伪装IP而浪费宝贵的代理流量并不合算。如何解决这个问题呢？</p><p>我们可以使用<strong>视频抓取</strong>，这个方法的原理是因为B站的服务器位于国内，因此我们可以先开梯子打开页面，等bilibili加载出视频后抓取视频，然后再关掉梯子下载，这样就既可以用直连的高网速下载，又不用浪费代理流量了！</p><hr><h2 id="软件："><a href="#软件：" class="headerlink" title="软件："></a>软件：</h2><ul><li>EagleGet： 提供快速下载功能（单源下载神器，这个软件用来下载一些冷门链接非常快，而且是免费的，比某雷要强得多）</li><li>任何一个有香港代理的梯子（这里推荐<a href="http://www.tuopushe.com/windscribe-emergency-connect.html" target="_blank" rel="noopener">Windscribe</a>）</li><li>Chrome或Chromium浏览器（用于支持EagleGet插件）</li></ul><h3 id="准备EagleGet："><a href="#准备EagleGet：" class="headerlink" title="准备EagleGet："></a>准备EagleGet：</h3><p>在浏览器的地址栏中输入<a href="http://www.eagleget.com" target="_blank" rel="noopener"><strong>http://www.eagleget.com</strong></a>,或点击链接直接访问，效果如图：<img src="https://i.loli.net/2019/08/27/w6kXe5qUVYNAJnF.png" alt="TIM截图20190827175353.png"></p><p>将鼠标悬浮在右上角的“<strong>DOWNLOAD</strong>”上会看到下拉菜单中有如下选项<img src="https://i.loli.net/2019/08/27/5OVQywa81G39i7k.png" alt="TIM截图20190827175922.png"></p><h4 id="准备EagleGet主体"><a href="#准备EagleGet主体" class="headerlink" title="准备EagleGet主体"></a>准备EagleGet主体</h4><p>单击<strong>EAGLEGET PORTABLE</strong>进入如下页面<img src="https://www.kanjiantu.com/images/2019/08/27/vSZmE9D7JupKfId100b68d998c81157.png" alt="vSZmE9D7JupKfId100b68d998c81157.png"></p><p>单击“<strong>DOWNLOAD EAGLEGET STABLE</strong>”下载EagleGet软件主体。如果你觉得官网的速度太慢了的话，也可以用我的网盘链接：<a href="https://pan.baidu.com/s/1qI9GXed4f9KgPsOFgV88bA" target="_blank" rel="noopener">链接</a></p><h4 id="准备EagleGet插件"><a href="#准备EagleGet插件" class="headerlink" title="准备EagleGet插件"></a>准备EagleGet插件</h4><p>单击<strong>CHROME EXTENSION</strong>进入Chrome网上应用店（这步需要在Chrome和Chromium中进行）（这步可能需要开梯子…）<br><img src="https://www.kanjiantu.com/images/2019/08/27/TIM2019082718214427781b5c1da322c5.png" alt="TIM2019082718214427781b5c1da322c5.png"><br>单击<strong>安装至Chrome</strong>安装此扩展。</p><h3 id="准备梯子："><a href="#准备梯子：" class="headerlink" title="准备梯子："></a>准备梯子：</h3><p><a href="http://www.tuopushe.com/windscribe-emergency-connect.html" target="_blank" rel="noopener"><strong>看这篇教程</strong></a></p><h3 id="准备浏览器："><a href="#准备浏览器：" class="headerlink" title="准备浏览器："></a>准备浏览器：</h3><p>Chromium压缩包：<a href="https://pan.baidu.com/s/1EaXvLsGBxvMZ_b8MpL_S3w" target="_blank" rel="noopener">链接</a></p><hr><h2 id="实际操作："><a href="#实际操作：" class="headerlink" title="实际操作："></a>实际操作：</h2><p>打开梯子，在B站找一部“仅限港澳台地区”的番剧，进入页面（这里以炎炎消防队第一集为例（这个视频8分15秒有一个圣光镜头…））<br><img src="https://www.kanjiantu.com/images/2019/08/27/TIM20190827183306461eec262226801c.png" alt="TIM20190827183306461eec262226801c.png"></p><p><strong>重头戏来了！</strong></p><p><strong>同时按”control”键，”shift”键和”I”键启动开发者工具</strong></p><p><img src="https://www.kanjiantu.com/images/2019/08/28/TIM20190828115949ec136e4de023de21.png" alt="TIM20190828115949ec136e4de023de21.png"></p><p>点击右上角的”Network”进入网络请求界面</p><p><img src="https://www.kanjiantu.com/images/2019/08/28/TIM20190828120031adb629afaed9eb6f.png" alt="TIM20190828120031adb629afaed9eb6f.png"></p><p>接下来<strong>刷新页面</strong>以加载网络请求，刷新之后，这个界面就变成了这样：</p><p><img src="https://www.kanjiantu.com/images/2019/08/28/TIM2019082812321767479674bb7169b1.png" alt="TIM2019082812321767479674bb7169b1.png"></p><p>耐心等待，直到视频加载完成（毕竟用了梯子以后网速会变慢很多）</p><p><img src="https://www.kanjiantu.com/images/2019/08/28/TIM20190828123246b58d08b727e9dd85.png" alt="TIM20190828123246b58d08b727e9dd85.png"></p><p>等到视频加载完成后，在左上角的”Filter”栏中输入”flv”（B站的视频资源是以flv格式存储的）过滤视频文件</p><p><img src="https://www.kanjiantu.com/images/2019/08/28/TIM20190828123408712a2c643defc935.png" alt="TIM20190828123408712a2c643defc935.png"></p><p>过滤后，在底部的请求栏中找到一个类型为”video/x-flv”的请求，单击它查看它的详细信息</p><p><img src="https://www.kanjiantu.com/images/2019/08/28/TIM20190828123438f99b61e46c8d7503.png" alt="TIM20190828123438f99b61e46c8d7503.png"></p><p>复制”Request URL”链接，这时候如果你的EagleGet插件工作正常的话已经弹出下载任务界面了。如果并没有弹出，那么打开EagleGet主界面</p><p><img src="https://i.loli.net/2019/08/28/NW3DfnM6YCQO7gx.png" alt="TIM截图20190828123623.png"></p><p>单击左上角的“✚”进入添加任务的界面，在上面的链接栏中粘贴刚才复制的链接</p><p><img src="https://i.loli.net/2019/08/28/exH2VLNv4AzRG8D.png" alt="TIM截图20190828123549.png"></p><p><strong>EagleGet高速的秘密</strong></p><p>单击左边的“连接”，进入连接设置，将“该任务的最大线程数”设为32（默认是8），如图</p><p><img src="https://i.loli.net/2019/08/28/aA3H9IqBGcbvudX.png" alt="TIM截图20190828123603.png"></p><p>开始下载，设置最大线程数以后，下载速度可以加速到5~6MBs(够快的)，很快就可以下载完成（再一次证明了B站的服务器位于国内）。</p><p>下载完成后，使用格式转换软件将下载的flv视频转化为MP4格式即可（这里用的是<a href="http://www.pcfreetime.com" target="_blank" rel="noopener">格式工厂</a>）<br><img src="https://i.loli.net/2019/08/28/xPfqwTkQ9YH8t2S.png" alt="TIM截图20190828133356.png"></p><hr><h2 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h2><p>放两张图让大家对比一下（炎炎消防队第一集 08:15）：</p><p>圣光版：</p><p><img src="https://www.kanjiantu.com/images/2019/08/28/TIM20190828134126f904401b17741dac.png" alt="TIM20190828134126f904401b17741dac.png"></p><p>无圣光版：</p><p><img src="https://www.kanjiantu.com/images/2019/08/28/TIM201908281342024ffdd3fa7b674471.png" alt="TIM201908281342024ffdd3fa7b674471.png"></p><hr><p><strong>如果你觉得这篇教程很好的话，请将其分享出去！</strong></p><p>ps：二次元图片建议使用<a href="https://www.kanjiantu.com" target="_blank" rel="noopener">看见图床</a>分享，无须担心删图，封号问题</p>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P4513 【小白逛公园】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-P4513-%E3%80%90%E5%B0%8F%E7%99%BD%E9%80%9B%E5%85%AC%E5%9B%AD%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-P4513-%E3%80%90%E5%B0%8F%E7%99%BD%E9%80%9B%E5%85%AC%E5%9B%AD%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="P4513-题解"><a href="#P4513-题解" class="headerlink" title="P4513 题解"></a>P4513 题解</h1><p><del>这还是我第一次给紫题写题解。。。</del></p><hr><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定$n$个公园的美观值（可能有负数），求出美观值和最大的连续花园区间 $[l,r]$ </p><p>实际上就是求<strong>区间最大子段和</strong>。。。</p><hr><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这是一道典型的区间统计问题，对于区间统计问题，我们一般使用<strong>线段树</strong>解决</p><p><a href="https://listener1379.site/2019/[数据结构]线段树/">线段树教程</a></p><p>为了求出区间最大子段和，对于每个区间x，我们需要计算以下四个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum[x] : x所代表区间的区间和</span><br><span class="line">ldat[x] : 紧靠区间左端的最大子段和</span><br><span class="line">rdat[x] : 紧靠区间右端的最大子段和</span><br><span class="line">dat[x] : 区间最大子段和</span><br></pre></td></tr></table></figure><p>这些值如何求出呢？</p><p>首先，我们考虑$dat$:</p><p><img src="https://i.loli.net/2019/09/05/JeHP9qKl45cXrj8.png" alt="无标题2.png"></p><p>对于一个区间的$dat$，它只能由三个途径得来:</p><ol><li>完全在左子区间，即左子区间的$dat$(绿色部分)</li><li>完全在右子区间，即右子区间的$dat$(红色部分)</li><li>跨越中点，即左子区间的$rsum$加上右子区间的$lsum$(黄色部分)</li></ol><p>那么，如何求出$ldat$和$rdat$呢？</p><p>由于$ldat$和$rdat$的求法相似，只是方向不同，这里只考虑$ldat$的求法 $\dots$</p><p><img src="https://i.loli.net/2019/09/05/fNOaXwJ75pejxMZ.png" alt="无标题3.png"></p><p>$ldat$更加简单，只有两种情况：</p><ol><li>完全在左子区间，即左子区间的$ldat$(绿色部分)</li><li>跨越中点，即左子区间的$sum +$ 右子区间的 $ldat$(红色部分)</li></ol><p>看到这里，相信大家都已经知道$rdat$怎么求了，这里就不在赘述。。。</p><p>至此，问题得到完美解决 $\dots$</p><p><del>怎么可能</del></p><hr><h2 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h2><ol><li>测试数据可能会出现$a&gt;b$的情况，需要进行交换…(血的教训)</li><li>查询时要同时返回4个数据并按要求归并…</li></ol><hr><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">500001</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_tree</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> l,r;</span><br><span class="line">  <span class="keyword">int</span> sum,lsum,rsum,dat;</span><br><span class="line">&#125;;</span><br><span class="line">segment_tree tree[maxn*<span class="number">4</span>];</span><br><span class="line"><span class="comment">//宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lsum(x) tree[x].lsum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rsum(x) tree[x].rsum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dat(x) tree[x].dat</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span><span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> c=getchar();</span><br><span class="line">  <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>;</span><br><span class="line">    c=getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">    c=getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//归并信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sum(p)=sum(p&lt;&lt;<span class="number">1</span>)+sum(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>); <span class="comment">//区间和</span></span><br><span class="line">  lsum(p)=max(lsum(p&lt;&lt;<span class="number">1</span>),sum(p&lt;&lt;<span class="number">1</span>)+lsum(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)); <span class="comment">//紧靠区间左端的最大子段和</span></span><br><span class="line">  rsum(p)=max(rsum(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>),sum(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+rsum(p&lt;&lt;<span class="number">1</span>));<span class="comment">//紧靠区间右端的最大子段和</span></span><br><span class="line">  dat(p)=max(&#123;dat(p&lt;&lt;<span class="number">1</span>),dat(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>),rsum(p&lt;&lt;<span class="number">1</span>)+lsum(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)&#125;); <span class="comment">//区间最大子段和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> <span class="comment">//建树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  l(p)=l,r(p)=r;</span><br><span class="line">  <span class="keyword">if</span>(l(p)==r(p))&#123; <span class="comment">//如果是叶子结点</span></span><br><span class="line">    sum(p)=lsum(p)=rsum(p)=dat(p)=read(); <span class="comment">//初始化的同时读入，高效建树</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  build(p&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">  build(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">  update(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> addr,<span class="keyword">int</span> c)</span> <span class="comment">//单点修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l(p)==r(p))</span><br><span class="line">  &#123;</span><br><span class="line">    sum(p)=lsum(p)=rsum(p)=dat(p)=c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid=(l(p)+r(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(addr&lt;=mid) change(p&lt;&lt;<span class="number">1</span>,addr,c);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(addr&gt;mid) change(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,addr,c);</span><br><span class="line">  update(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">segment_tree <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> <span class="comment">//区间查询（要同时返回4个数据）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=l(p) &amp;&amp; r&gt;=r(p)) <span class="keyword">return</span> tree[p];</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0xc0c0c0c0</span>;</span><br><span class="line">  <span class="keyword">int</span> mid=(l(p)+r(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> ask(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">  <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> ask(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    segment_tree x,y,ans;</span><br><span class="line">    x=ask(p&lt;&lt;<span class="number">1</span>,l,r),y=ask(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    ans.sum=x.sum+y.sum;</span><br><span class="line">    ans.lsum=max(x.lsum,x.sum+y.lsum);</span><br><span class="line">    ans.rsum=max(y.rsum,y.sum+x.rsum);</span><br><span class="line">    ans.dat=max(&#123;x.dat,y.dat,x.rsum+y.lsum&#125;);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  return ans;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k,a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  n=read(),m=read();</span><br><span class="line">  build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    k=read();</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      a=read(),b=read();</span><br><span class="line">      <span class="keyword">if</span>(a&gt;b) swap(a,b);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(<span class="number">1</span>,a,b).dat);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      a=read(),b=read();</span><br><span class="line">      change(<span class="number">1</span>,a,b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法笔记】树链剖分</title>
      <link href="/2019/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
      <url>/2019/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="【算法笔记】树链剖分"><a href="#【算法笔记】树链剖分" class="headerlink" title="【算法笔记】树链剖分"></a>【算法笔记】树链剖分</h1><p><em>强烈建议在阅读本文之前已经掌握前置知识 <strong>线段树</strong>，如果你没有，请先阅读<a href="https://listener1379.site/2019/【数据结构】线段树/">这篇文章</a></em></p><p><em>不知道树是什么的，请前往<a href="https://baike.sogou.com/v101597958.htm?fromTitle=树" target="_blank" rel="noopener">搜狗百科-树</a></em></p><p>树链剖分，又名轻重路径剖分、树剖，是一种 <del>看起来十分高大上实际很水的能让你代码强行增加180行的不那么容易爆炸(并不)的</del>算法，本质上是将树转化为一系列<strong>重链</strong>和<strong>轻边</strong>（这两个东西的定义后边会讲），然后用<strong>线段树</strong>（或一切支持<strong>区间修改和查询</strong>操作的数据结构，但其中线段树能维护的信息最广泛）进行存储。</p><p>树链剖分十分实用（前提是你线段树写的很熟练，不然<strong>满屏RE</strong>。。。），能将复杂的树上维护转化为<del>简单</del>相对不那么复杂的区间维护。</p><p>树链剖分的作用有：</p><ul><li><del>证明出题人是个毒瘤</del></li><li>修改静态树上两点间最短路径上的所有点权（边权可以边转点解决）</li><li>查询静态树上两点间最短路径上的点权和及最值（或任何你可以想到的满足区间可加性的信息）</li><li>修改一个点及其子树上的所有点权</li><li>查询一个点及其子树上的所有点权和及最值（其他信息同上）</li></ul><p>树剖也能解决，但一般不用树剖解决的问题有：</p><ul><li>求LCA（60行和180行你选哪个）</li><li>只维护树上两点间最短路径上的所有点权（树上差分就可以）</li><li>只查询树上两点间最短路径上的点权和（依然是树上差分）</li></ul><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先给出几个定义：</p><blockquote><ul><li>重儿子：一个节点的子树中节点数最多的子树的根（如果有多个可以取任意一个）</li><li>重链：由重儿子连接形成的链</li><li>轻边：树中不属于重链的其他边</li></ul></blockquote><p>树链剖分示意，其中点上的数是编号，加粗的边为重边：</p><p><img src="https://i.loli.net/2019/08/28/GrlkpRO7yzvbZAj.png" alt="5c24d0664c185.png"></p><p>上面的图中，点1,2,3,4,5,6构成一条重链，点7，8,9,11,13构成一条重链，点12、14分别构成两条长度为1的重链（自己）</p><p>树链剖分的性质：</p><ul><li>树上的所有点属于且仅属于一条重路径</li><li>设size[x]为x的子树大小，则如果(u,v)为轻边，size[u]&lt;=size[u]/2(因为u已经有一个重儿子，而如果v的子树大小超过u的一半，则v应该是重儿子)</li><li>因此，对于任何非根节点u，在u到根的路径上，轻边和重链最多有 $logn$条</li></ul><hr><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>为了预处理树剖的操作，我们需要计算如下几个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对树中的每一个节点x</span><br><span class="line">father[x]:x在树中的父亲</span><br><span class="line">dep[x]:x的深度</span><br><span class="line">size[x]:x的子树节点数</span><br><span class="line">hson[x]:x的重儿子</span><br><span class="line">top[x]:x所在重链的顶部节点（深度最小）</span><br><span class="line">seg[x]:x在线段树中的位置（下标）</span><br><span class="line">rev[x]:线段树中第x个位置对应的节点编号</span><br></pre></td></tr></table></figure><p>我们需要两遍dfs来计算这些值，第一次DFS可以计算前四个值，第二次DFS可以计算后三个值。预处理代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  size[u]=<span class="number">1</span>; <span class="comment">//子树大小默认为1</span></span><br><span class="line">  dep[u]=dep[f]+<span class="number">1</span>; <span class="comment">//深度</span></span><br><span class="line">  father[u]=f; <span class="comment">//记录父亲</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[u].size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> v=e[u][i]; <span class="comment">//使用vector存图</span></span><br><span class="line">    <span class="keyword">if</span>(v!=f)<span class="comment">//排除父亲</span></span><br><span class="line">    &#123;</span><br><span class="line">      dfs1(v,u);</span><br><span class="line">      size[u]+=size[v]; <span class="comment">//累加子树大小</span></span><br><span class="line">      <span class="keyword">if</span>(size[v]&gt;size[hson[u]]) hson[u]=v; <span class="comment">//如果v的子树大小比当前重儿子的大小大那么更新重儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(hson[u]) <span class="comment">//先走重儿子，使重儿子在线段树中的序号连续,这样才能用区间操作维护重链信息</span></span><br><span class="line">  &#123;</span><br><span class="line">    seg[hson[u]]=++tot;<span class="comment">//插入点</span></span><br><span class="line">    top[hson[u]]=top[u];<span class="comment">//u和重儿子同属于一条重链</span></span><br><span class="line">    rev[tot]=hson[u]; <span class="comment">//此时tot为当前点</span></span><br><span class="line">    dfs2(hson[u],u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[u].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> v=e[u][i];</span><br><span class="line">      <span class="keyword">if</span>(v!=f &amp;&amp; v!=hson[u]) <span class="comment">//排除父亲也不是重儿子</span></span><br><span class="line">      &#123;</span><br><span class="line">        seg[v]=++tot;</span><br><span class="line">        top[v]=v; <span class="comment">//轻儿子一定是重链的顶部节点</span></span><br><span class="line">        rev[tot]=v;</span><br><span class="line">        dfs2(v,u);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/*other codes*/</span></span><br><span class="line">  dfs1(root,<span class="number">0</span>);</span><br><span class="line">  seg[root]=tot=<span class="number">1</span>;</span><br><span class="line">  rev[<span class="number">1</span>]=top[root]=root;</span><br><span class="line">  dfs2(root,<span class="number">0</span>)</span><br><span class="line">  build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">  <span class="comment">/*other codes*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="1-路径查询"><a href="#1-路径查询" class="headerlink" title="1.路径查询"></a>1.路径查询</h4><p>给定两个点x,y，统计x到y最短路径上的信息：</p><ul><li>如果x、y属于一条重链（即top[x] $=$ top[y]），那么直接进行一次线段树的区间查询即可</li><li>如果x、y属于两条重链（即top[x] $\ne$ top[y]），那么一定是由x走到 $LCA(x,y)$ 再走到y，此时<ul><li>首先找到top深度较大的点（因为LCA一定不可能在顶部节点深度较大的重链上）</li><li>假设这个点是x，那x可以直接跳到father[top[x]],并在线段树上统计[seg[x]~seg[top[x]]]的信息（这会使x跳到一条离根更近的重链上）</li><li>重复上面的操作直到top[x] $=$ top[y]，此时用一次区间查询统计[x~y]的信息</li></ul></li></ul><p>代码(以统计和为例)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qrange</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(top[x]!=top[y]) &#123; <span class="comment">//当x、y属于两条重链</span></span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="comment">//找到top深度较大的点 </span></span><br><span class="line">    swap(x,y);</span><br><span class="line">    ans+=query(<span class="number">1</span>,seg[top[x]],seg[x]); <span class="comment">//区间查询，统计[seg[x]~seg[top[x]]]的信息</span></span><br><span class="line">    x=father[top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">  ans+=query(<span class="number">1</span>,seg[x],seg[y]);<span class="comment">//统计[x~y]的信息</span></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-路径修改"><a href="#2-路径修改" class="headerlink" title="2.路径修改"></a>2.路径修改</h4><p>给定两个点x,y，更新x到y最短路径上的信息：</p><p>方法同上，只不过将区间查询换成区间修改。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crange</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top[x]!=top[y]) &#123; <span class="comment">//当x、y属于两条重链</span></span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="comment">//找到top深度较大的点 swap(x,y);</span></span><br><span class="line">        swap(x,y);</span><br><span class="line">    update(<span class="number">1</span>,seg[top[x]],seg[x],k); <span class="comment">//更新[seg[x]~seg[top[x]]]的信息</span></span><br><span class="line">    x=father[top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">  update(<span class="number">1</span>,seg[x],seg[y],k);<span class="comment">//更新[x~y]的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-子树查询"><a href="#3-子树查询" class="headerlink" title="3.子树查询"></a>3.子树查询</h4><p>统计x及其子树上的信息：</p><p>这个更简单了，由于x的子树在线段树上是连续的，同时size[x]又储存了x的子树大小，因此直接用一次区间查询统计[x~x+size[x]-1]上的信息即可</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qson</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> query(<span class="number">1</span>,seg[x],seg[x]+size[x]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-子树修改"><a href="#3-子树修改" class="headerlink" title="3.子树修改"></a>3.子树修改</h4><p>更新x及其子树上的信息：</p><p>方法同上，只不过将区间查询换成区间修改。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cson</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  update(<span class="number">1</span>,seg[x],seg[x]+size[x]<span class="number">-1</span>,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ul><li><a href="https://www.luogu.org/problem/P3384" target="_blank" rel="noopener">P3384 【模板】树链剖分</a>（模板题）</li><li><a href="https://www.luogu.org/problem/P2146" target="_blank" rel="noopener">P2146 [NOI2015]软件包管理器</a>（用0/1来维护）</li><li><a href="https://www.luogu.org/problem/P3401" target="_blank" rel="noopener">P3401 洛谷树</a>（边转点）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P1063 【能量项链】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-P1063-%E3%80%90%E8%83%BD%E9%87%8F%E9%A1%B9%E9%93%BE%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-P1063-%E3%80%90%E8%83%BD%E9%87%8F%E9%A1%B9%E9%93%BE%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="P1063-题解"><a href="#P1063-题解" class="headerlink" title="P1063 题解"></a>P1063 题解</h1><p><em>这题建议在做完<a href="https://www.luogu.org/problem/P1880" target="_blank" rel="noopener">P1880 石子合并</a>之后再做，思路其实和这题差不多</em></p><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道经典的区间动规题，对于这种题我们一般用记搜解决（其实是因为刷表法过于抽象$\dots$ ） </p><p>首先是珠子的处理，这里有一个问题：<strong>前一颗珠子的头标记</strong>是<strong>后一颗珠子的尾标记</strong>，在DP时要特别注意这一点。另外一个问题就是珠子是成<strong>环状</strong>的，这样的环我们要使用<strong>拆成链后复制一遍接在环尾</strong>的方法，看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于前一颗珠子的头标记是后一颗珠子的尾标记，</span></span><br><span class="line"><span class="comment">//因此我们可以用a数组直接同时存储当前竹子的头标记和上一颗珠子的尾标记</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        a[i+n]=a[i]; <span class="comment">//复制一遍接在环尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">2</span>*n+<span class="number">1</span>]=a[<span class="number">1</span>]; <span class="comment">//最后一颗珠子的尾标记</span></span><br></pre></td></tr></table></figure><p>接下来是DP的部分，DP的思想其实就是：（为了方便，这里用head[x]和tail[x]来代指x的头标记和尾标记（<strong>就是原数组中的a[x]和a[x+1]）</strong>）</p><p>设分界点为m，则<strong>合成l到r的总收益$=$合成head[l]到tail[m-1]的总收益(因为要使l和m接触)$+$合成head[m+1]到tail[r]的总收益 (因为要使m和r接触)$+$head[l]$\times$tail[m]$\times$tail[r] (再合并l和r)</strong></p><p>画成图就是这样子：</p><p><img src="https://i.loli.net/2019/10/23/HrKELUjw4J2NcmC.png" alt></p><p><strong>当然，如果区间只有2项，则只能在l处合并，因此其总收益$=$head[l]$\times$tail[l]$\times$tail[r]</strong></p><p>接下来就可以给出DP代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//f为记忆化数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[l][r]!=<span class="number">0</span>) <span class="keyword">return</span> f[l][r];</span><br><span class="line">    <span class="keyword">if</span>(l==r<span class="number">-1</span>) <span class="keyword">return</span> a[l]*a[r]*a[r+<span class="number">1</span>];<span class="comment">//边界（只有2项）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;r;k++)<span class="comment">//枚举分界点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注：a[x+1]就是tail[x]</span></span><br><span class="line">        ans=max(ans,dp(l,k)+dp(k+<span class="number">1</span>,r)+a[l]*a[k+<span class="number">1</span>]*a[r+<span class="number">1</span>]);<span class="comment">//更新答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[l][r]=ans;<span class="comment">//返回并记忆化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于环拆成链后一共有<strong>n种可能的开头</strong>，所以需要<strong>n次DP</strong>计算出答案</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    ans=max(ans,dp(i,i+n<span class="number">-1</span>));<span class="comment">//head[i]到tail[i+n]就是a[i]到a[i+n-1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于时间复杂度"><a href="#关于时间复杂度" class="headerlink" title="关于时间复杂度"></a>关于时间复杂度</h2><p>这题的时间复杂度很多人认为是$O(n^4)$,会超时，但其实并不是这样。这个算法的实际复杂度其实是$O(n^3)$。</p><p>为什么呢？因为在<strong>执行下一次DP时，上一次DP计算出的值是可以直接使用的。</strong></p><p>让我们模拟一下算法执行的过程：<em>（设n=5）</em></p><p>第一次DP时，要计算$n^2$个值，如图所示：(图中的绿色部分)</p><p><img src="https://i.loli.net/2019/10/24/BpcYTkR3xHFhrvy.png" alt="TIM截图20191024215559.png"></p><p>这时，需要计算$n^2$个值，每个值需要$O(n)$的时间去计算，因此第一次DP的总复杂度为$O(n^3)$。</p><p>第二次DP时，图形变成了这样：</p><p><img src="https://i.loli.net/2019/10/24/u51nUeGwHaY4V7k.png" alt="TIM截图20191024220023.png"></p><p>这时，图中的黄色部分是<strong>已经计算好的值</strong>，可以直接使用，只有红色部分需要计算，而这样的格子一共有$2n-1$个，因此第二次DP只需要$O(n^2)$的时间去计算，第3~n次DP同理。</p><p>所以，整个算法的时间复杂度为$O(n^3+n(2n-1)\times n)=O(n^3)$。</p><p><del>(话说我好像是唯一一篇有时间复杂度分析的题解…)</del></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><em>关键部分的注释之前已经给过了，这里就不给了</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">201</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[l][r]!=<span class="number">0</span>) <span class="keyword">return</span> f[l][r];</span><br><span class="line">    <span class="keyword">if</span>(l==r<span class="number">-1</span>) <span class="keyword">return</span> a[l]*a[r]*a[r+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;r;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=max(ans,dp(l,k)+dp(k+<span class="number">1</span>,r)+a[l]*a[k+<span class="number">1</span>]*a[r+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[l][r]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        a[i+n]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">2</span>*n+<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=max(ans,dp(i,i+n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://listener1379.site">欢迎来到博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】线段树</title>
      <link href="/2019/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2019/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p><strong>线段树是什么？</strong></p><p>线段树是一种<del>能让你代码强行增加50行的极容易爆炸的万金油</del>数据结构，用于<del>优雅</del>暴力地解决对一个区间上<strong>满足区间可加性（即可由两个子区间的信息得到当前区间信息）</strong> 的 <strong>区间修改和区间查询</strong>问题。</p><h2 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h2><p>将区间划分为左端点到中点（即左子区间）和中点+1到右端点（即右子区间）的两个子区间，然后对两个子区间继续划分，直到划分到单个元素（即左端点=右端点）</p><p><strong>示意图：</strong><br><img src="https://www.kanjiantu.com/images/2019/08/27/c0dd297d009ddb5d3d37da29c291da7c07e3cb5a0c40b2ec.png" alt="c0dd297d009ddb5d3d37da29c291da7c07e3cb5a0c40b2ec.png"></p><p>不难看出线段树除了最下面一层，其他的部分一定是一颗<strong>完全二叉树</strong>，这意味着整棵树可以使用“父子二倍法”（左儿子编号为父亲编号 $\times$ 2，右儿子编号为父亲编号 $\times$ 2 $+$ 1）存储在一个数组中。同时，因为还要考虑到最后一层，数组的大小应开到n $\times$ 4大小。</p><p>线段树的一个很重要的性质就是一棵[1~n]的线段树的深度最大为 $log_2  n+1$,这也意味着线段树可在$O(logn)$的时间复杂度内完成所有操作。</p><hr><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以<a href="https://www.luogu.org/problem/P3372" target="_blank" rel="noopener">洛谷P3372 【模板】线段树 1</a>的维护最大值为例<br>首先，我们给线段树中每个元素一个sum变量存储该元素代表区间的区间和，叶子结点的sum是原数组当前位置的值，非叶节点的sum是其左右子节点sum的和，如当原数组为<br><img src="https://www.kanjiantu.com/images/2019/08/27/3dd6bf7464e1e756f.png" alt="3dd6bf7464e1e756f.png"></p><p>时，对应的线段树为<img src="https://www.kanjiantu.com/images/2019/08/27/2cd920dd97dbafe0d.png" alt="2cd920dd97dbafe0d.png"></p><p>节点结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segmenttree</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> l,r,sum,add;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l <span class="comment">//当前区间左端点</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r <span class="comment">//当前区间右端点</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum <span class="comment">//区间和</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> add(x) tree[x].add <span class="comment">//延迟标记（这个后面会讲）</span></span></span><br><span class="line">&#125;tree[maxn];</span><br></pre></td></tr></table></figure><hr><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>操作有递归和非递归两种形式，递归式相对于非递归式更直观，因此这里讲解递归式。</p><p>非递归式和递归式本同末异，考试时按照数据规模而定。</p><h3 id="建树："><a href="#建树：" class="headerlink" title="建树："></a>建树：</h3><p>按照之前提到的定义，从根节点([1~n])向左右两边递归，递归到叶子结点就将该节点sum设为其在原数组中对应的值，回溯时将当前节点的sum设为其左右子节点sum的和。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  l(p)=l;r(p)=r; <span class="comment">//设置端点</span></span><br><span class="line">  <span class="keyword">if</span>(l==r) &#123; sum(p)=num[l]; <span class="keyword">return</span>;&#125; <span class="comment">//如果是叶子节点</span></span><br><span class="line">  <span class="keyword">int</span> mid=((l+r)&gt;&gt;<span class="number">1</span>); <span class="comment">//位运算，右移1位相当于/2，左移同理</span></span><br><span class="line">  build(p&lt;&lt;<span class="number">1</span>,l,mid); <span class="comment">//向左递归</span></span><br><span class="line">  build(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r) <span class="comment">//向右递归，一个偶数|1相当于+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度为$O(nlogn)$</p><h3 id="区间查询："><a href="#区间查询：" class="headerlink" title="区间查询："></a>区间查询：</h3><p>设查询区间的左端点为 $l$,右端点为 $r$,当前区间的左端点为 $l_1$,右端点为 $r_1$,中点为$mid$ ,则</p><ul><li>当 $l \leq l_1$ 且 $r \geq r_1$时 直接返回当前区间的sum,因为当前区间<strong>已经涵盖了子区间的全部信息</strong>。</li><li>当 $l \leq mid$时，向左递归，$r_1=mid$（此时查询区间一定涵盖左子区间的一部分）</li><li>当 $r &gt; mid$时，向右递归，$l_1=mid+1$ （此时查询区间一定涵盖右子区间的一部分）</li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=l(p) &amp;&amp; r&gt;=r(p)) <span class="keyword">return</span> sum(p); <span class="comment">//完全包含</span></span><br><span class="line">  <span class="keyword">int</span> mid=((l(p)+r(p))&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) ans+=query(p&lt;&lt;<span class="number">1</span>,l,mid); <span class="comment">//向左递归，累加左子树答案</span></span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) ans+=query(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r); <span class="comment">//向右递归，累加左子树答案</span></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度为$O(logn)$</p><h3 id="区间修改与延迟标记："><a href="#区间修改与延迟标记：" class="headerlink" title="区间修改与延迟标记："></a>区间修改与延迟标记：</h3><p>当进行区间修改时，我们依然可以设查询区间的左端点为 $l$,右端点为 $r$,当前区间的左端点为 $l_1$,右端点为 $r_1$,中点为$mid$，同时查询操作也满足这两条性质：</p><ul><li>当 $l \leq mid$时，向左递归，$r_1=mid$（此时查询区间一定涵盖左子区间的一部分）</li><li>当 $r &gt; mid$时，向右递归，$l_1=mid+1$ （此时查询区间一定涵盖右子区间的一部分）</li></ul><p>但当出现完全覆盖的情况时，事情就变得不那么简单了，一个一个深入更新会使单次修改的复杂度高达 $O(n)$,这是我们所无法接受的。这时，我们就要引入<strong>延迟标记</strong>。</p><p>试想一下，如果你花费很大的代价更新了节点p的子树，但在之后的查询中却根本没有访问到它们，那更新p的子树岂不是白费力气？因此，我们可以在区间修改出现“完全覆盖”情况时也直接返回，但要给当前节点打上一个代表“<strong>当前节点已被更新，但其子节点尚未被更新</strong>”的延迟标记（这里取名add）。（如果操作是相容的（如加法），那在打标记前无需下传原来的标记。如果操作是不相容的（如赋值），那在打标记前需下传原来的标记。）</p><p>在以后的查询操作中，如果遇到了有延迟标记的节点，便将其的两个子节点更新并打上延迟标记，并擦除当前节点的延迟标记（即将延迟标记<strong>下传一层</strong>），这样就减少了大量无用的更新操作 <del>（虽然本质上依旧是暴力）</del>。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="comment">//下传标记</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(add(p))</span><br><span class="line">  &#123;</span><br><span class="line">    add(p&lt;&lt;<span class="number">1</span>)+=add(p);</span><br><span class="line">    add(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+=add(p);</span><br><span class="line">    sum(p&lt;&lt;<span class="number">1</span>)+=add(p)*(r(p&lt;&lt;<span class="number">1</span>)-l(p&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>); <span class="comment">//区间和增量=数值增量*区间长</span></span><br><span class="line">sum(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+=add(p)*(r(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)-l(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+<span class="number">1</span>); <span class="comment">//区间和增量=数值增量*区间长</span></span><br><span class="line">    add(p)=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//更新后的区间查询，增加了下穿标记的操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=l(p) &amp;&amp; r&gt;=r(p)) <span class="keyword">return</span> sum(p); <span class="comment">//完全包含</span></span><br><span class="line">  spread(p);<span class="comment">//下传标记</span></span><br><span class="line">  <span class="keyword">int</span> mid=((l(p)+r(p))&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) ans+=query(p&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) ans+=query(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p <span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=l(p) &amp;&amp; r&gt;=r(p))&#123;</span><br><span class="line">sum(p)+=c*(r(p)-l(p)+<span class="number">1</span>); <span class="comment">//区间和增量=数值增量*区间长</span></span><br><span class="line">add(p)+=c;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);<span class="comment">//下传标记</span></span><br><span class="line"><span class="keyword">int</span> mid=(l(p)+r(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) update(p&lt;&lt;<span class="number">1</span>,l,r,c); <span class="comment">//更新左子树</span></span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) update(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,c); <span class="comment">//更新右子树</span></span><br><span class="line">sum(p)=sum(p&lt;&lt;<span class="number">1</span>)+sum(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>); <span class="comment">//更新当前点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度为$O(logn)$</p><hr><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><ul><li><a href="https://www.luogu.org/problem/P3373" target="_blank" rel="noopener">洛谷 P3373 【模板】线段树 2</a></li><li><a href="https://www.luogu.org/problem/P4513" target="_blank" rel="noopener">洛谷 P4513 小白逛公园</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法笔记】快速幂</title>
      <link href="/2019/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%91%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2019/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%91%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h1 id="【算法笔记】快速幂"><a href="#【算法笔记】快速幂" class="headerlink" title="【算法笔记】快速幂"></a>【算法笔记】快速幂</h1><p><del>其实写这篇文章的主要目的是练习LATEX（大雾）</del></p><p>朴素地计算幂的方法就是计算出$b$个$a$的乘积，即<br>$$ \prod_{i=1}^b a=\underbrace{a \times a \times a \times \dots \times a}_b $$<br>（因为这篇文章主要介绍快速幂，代码就不贴了）</p><p>但是很明显，如果用这个算法去计算$2^{100000000000000}$,那么一定会<strong>T飞</strong>，原因很简单：<br>这个算法的时间复杂度是$O(n)$，对于计算幂这样频繁的操作来说代价太大了。</p><p>于是，我们就有了快速幂。</p><p>快速幂，又称平方求幂法，是一种基于<strong>分治</strong>思想在 $O(logn)$ 的时间复杂度内求幂的方法。</p><p>首先，一个显而易见的事实是:<br>$$ n^a \times n^b=n^{a+b} $$</p><p>于是当n为奇数有：<br>$$ a^b=a^{ \lfloor\frac{n}{2}\rfloor + \lfloor\frac{n}{2}\rfloor + 1} $$<br>当n为偶数有：<br>$$ a^b=a^{ \frac{n}{2} + \frac{n}{2}} $$<br>所以<br>$$ a^b=\begin{cases}<br>  a &amp;b=1 \cr<br>  a^{\lfloor\frac{n}{2}\rfloor} \times a^{\lfloor\frac{n}{2}\rfloor} \times a &amp;b \nmid 2 \cr<br>  a^{\frac{n}{2}} \times a^{\frac{n}{2}} &amp;b\mid 2<br>\end{cases}  $$</p><p>快速幂代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> ksm(a,b/<span class="number">2</span>)*ksm(a,b/<span class="number">2</span>)*a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> ksm(a,b/<span class="number">2</span>)*ksm(a,b/<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速幂取模</strong></p><p>有时候，因为求出的幂太大，我们不仅想要求出幂，还想求出幂对一个指定的数取模的结果，这时候，我们就要利用余数的可乘性，即</p><p><code>(a mod m) * (b mod m) = (a*b) mod m</code></p><p>(抱歉这里用不了LATEX)</p><p>方法很简单，在快速幂计算时的每一处乘法加上取模就可以了<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> (((ksm(a,b/<span class="number">2</span>,mod)*(ksm(a,b/<span class="number">2</span>,mod))%mod*a)%mod;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> ((ksm(a,b/<span class="number">2</span>,mod)*(ksm(a,b/<span class="number">2</span>,mod))%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P1462 【通往奥格瑞玛的道路】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-P1462-%E3%80%90%E9%80%9A%E5%BE%80%E5%A5%A5%E6%A0%BC%E7%91%9E%E7%8E%9B%E7%9A%84%E9%81%93%E8%B7%AF%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-P1462-%E3%80%90%E9%80%9A%E5%BE%80%E5%A5%A5%E6%A0%BC%E7%91%9E%E7%8E%9B%E7%9A%84%E9%81%93%E8%B7%AF%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="P1462-题解"><a href="#P1462-题解" class="headerlink" title="P1462 题解"></a>P1462 题解</h1><hr><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个$n$个点的无向图，求在满足从$1$到$n$的最短路边权和 $\leq b$ 的情况下，所经过的点的最大点权的最小值。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>带有 <strong>“最大值最小”</strong> 的“双最”字样的最优化题目一般比较难直接求解，这时候我们不妨用二分的思想，将最优化问题转换为判断合法性问题。</p><p>二分代码模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">  mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(check(mid)) ans=mid,r=mid<span class="number">-1</span>; <span class="comment">//如果解合法，记录答案并缩小左边界</span></span><br><span class="line">  <span class="keyword">else</span> l=mid+<span class="number">1</span>;<span class="comment">//否则缩小右边界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="check-函数的设计："><a href="#check-函数的设计：" class="headerlink" title="check()函数的设计："></a>check()函数的设计：</h3><p>首先，假设我们已经找到了一个解 $val$，那么所有点权 $&gt; val$的点就不能被访问了(因为如果这样做就不满足解)。然后再求出$1$到$n$的最短路 <em>(SPFAer和Dijkstrer们可以不要争了，这个优先队列BFS就可以做，还比你们都快 233)</em>，之后判断最短路的权值和是否 $\leq b$ ，如果不满足则说明解不合法 <del>（会被揍死）</del>。</p><h3 id="一些小坑点："><a href="#一些小坑点：" class="headerlink" title="一些小坑点："></a>一些小坑点：</h3><ul><li>二分时需要判断 <strong>“无论如何也无法到达的情况”</strong> ；</li><li>fi≤1000000000,因此直接二分会T飞，要先离散化；</li><li>ci≤1000000000,记得开 long long 不然炸飞；</li></ul><hr><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext/pb_ds/priority_queue.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,m,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span><span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> c=getchar();</span><br><span class="line">  <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> || c&gt;<span class="string">'9'</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>;</span><br><span class="line">    c=getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">    s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">    c=getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BFS的记录结构体</span></span><br><span class="line"><span class="comment"> * @param cur 当前点</span></span><br><span class="line"><span class="comment"> * @param c 已经扣掉的血量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span>&#123;</span></span><br><span class="line">  ll cur,c;</span><br><span class="line">  note(ll a,ll b):cur(a),c(b) &#123;&#125;</span><br><span class="line">  note() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//没什么好说的，比较运算符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(note a,note b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.c&gt;b.c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//pbds的黑科技堆，详细描述可以看这里：https://blog.xehoth.cc/pb-ds-PriorityQueue/</span></span><br><span class="line"><span class="keyword">typedef</span> __gnu_pbds::priority_queue&lt;note,cmp,__gnu_pbds::pairing_heap_tag&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector数组存图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">  ll to;ll w;</span><br><span class="line">  edge(ll a,ll b):to(a),w(b) &#123;&#125;</span><br><span class="line">  edge() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; e[maxn];</span><br><span class="line">ll v[maxn];<span class="comment">//点权数组</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加一条x到y,权值为w的边</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(ll x,ll y,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  e[x].push_back(edge(y,w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS部分</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function">ll <span class="title">bfs</span><span class="params">(ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">  heap q;</span><br><span class="line">  q.push(note(<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">  vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    note cu=q.top();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">if</span>(cu.cur==n)&#123;</span><br><span class="line">      <span class="keyword">return</span> cu.c;</span><br><span class="line">    &#125;</span><br><span class="line">    ll&amp; st=cu.cur;</span><br><span class="line">    ll&amp; co=cu.c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[st].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      ll&amp; to=e[st][i].to;</span><br><span class="line">      <span class="keyword">if</span>(!vis[to] &amp;&amp; v[to]&lt;=val)</span><br><span class="line">      &#123;</span><br><span class="line">        q.push(note(to,co+e[st][i].w));</span><br><span class="line">        vis[to]=<span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;<span class="comment">//如果到不了返回无穷大</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll lsv[maxn];<span class="comment">//离散数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  n=read(),m=read(),b=read();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lsv[i<span class="number">-1</span>]=v[i]=read();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,w;i&lt;=m;i++) &#123;</span><br><span class="line">    x=read(),y=read(),w=read();</span><br><span class="line">    <span class="keyword">if</span>(x!=y) addedge(x,y,w),addedge(y,x,w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//离散化</span></span><br><span class="line">  sort(lsv,lsv+n);</span><br><span class="line">  <span class="keyword">int</span> sz=unique(lsv,lsv+n)-lsv;</span><br><span class="line">  <span class="comment">//二分</span></span><br><span class="line">  <span class="keyword">int</span> l=<span class="number">0</span>,r=sz,mid,ans=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">  &#123;</span><br><span class="line">    mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(bfs(lsv[mid])&lt;=b) ans=mid,r=mid<span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ans==<span class="number">-1</span>)&#123;<span class="comment">//如果答案没被更新过即为“不可到达”</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"AFK\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,lsv[ans]);<span class="comment">//输出答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总时间复杂度：$O(nlogn * logn) = O(nlog^2 n)$,比几乎所有题解都要快</p>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P3353 【在你窗外闪耀的星星】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-P3353-%E3%80%90%E5%9C%A8%E4%BD%A0%E7%AA%97%E5%A4%96%E9%97%AA%E8%80%80%E7%9A%84%E6%98%9F%E6%98%9F%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-P3353-%E3%80%90%E5%9C%A8%E4%BD%A0%E7%AA%97%E5%A4%96%E9%97%AA%E8%80%80%E7%9A%84%E6%98%9F%E6%98%9F%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="P3353-题解"><a href="#P3353-题解" class="headerlink" title="P3353 题解"></a>P3353 题解</h1><hr><p>在做<a href="https://www.luogu.org/problemnew/show/P1502" target="_blank" rel="noopener">P1502 窗口的星星</a>时偶然发现了这道题，看到这题的名字以后好奇心大增，就决定点进去看看。。。</p><p><del>本来看到这只是道黄题没打算做，直到这题超级长的题面让我想起了我在学校的【已编辑】，于是决定A之以明志</del></p><hr><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>天空中有$n$颗星星，求宽度为$W$的窗户（高度无限）最多能圈住亮度为多少的星星。</p><p>仔细分析后，我们发现我们可以将天空视作一个数轴，将$x$坐标相等的星星亮度累加在一起（反正$y$坐标没用），然后依次统计出每个长度为$W$的区间和，最后求最大值就可以了。</p><hr><h2 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h2><p>由上面的题目大意，可以十分直接地得到一个暴力算法——由$W$到最大的$x$坐标循环枚举，每次用循环求出$i-w$到$i$的区间和，然后取最大值</p><p><em>期望得分:(想要期望得分？这玩意估计也只能对拍用)</em></p><hr><h2 id="正解——前缀和"><a href="#正解——前缀和" class="headerlink" title="正解——前缀和"></a>正解——前缀和</h2><p>首先，我们要介绍一下<strong>前缀和</strong>：</p><p><strong>前缀和，指在一个序列中由序列起始位置到当前位置的和，如</strong><br>$$Sum_i=A_1+A_2+A_3+A_4+···+A_i$$</p><p>前缀和的作用是 $O(1)$ 地维护静态区间和，原理为：<br>$$Sum_i=A_1+A_2+A_3+A_4+···+A_i$$</p><p>$$Sum_j=A_1+A_2+A_3+A_4+···+A_j,j&gt;i$$</p><p>则$Sum_j$一定包含$Sum_i$，即<br>$$Sum_j=A_1+A_2+A_3+A_4+···+A_i+A_(i+1_)+···+A_j$$</p><p>则<br>$$Sum_j-Sum_i=(A_1+A_2+A_3+A_4+···+A_i+A_(i+1_)+···+A_j)$$<br>$$-(A_1+A_2+A_3+A_4+···+A_i)=A_(i+1_)+A_(i+2_)+···+A_j$$<br>所以<br>$$ A_(i+1_)+A_(i+2_)+···+A_j$$<br>即为i到j的区间和 </p><p>由此，我们可以得出最后的思路——在输入完成后，$O(n)$ 预处理出<strong>前缀和数组sum</strong>，然后对每个区间和操作，返回<strong>sum[i]-sum[i-w]</strong> (因为只有i-w+1 ~ i会被计算)，然后取最大值即可。</p><p>至此，问题得到完美解决。<del>完结撒花</del></p><p>贴代码~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxw=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,w,x,b;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxx=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> br[maxw];<span class="comment">//亮度数组</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxw];<span class="comment">//前缀和数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="literal">false</span>);<span class="comment">//流式I/O速度优化</span></span><br><span class="line">  <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="comment">//流式I/O速度优化</span></span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;w;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;b;</span><br><span class="line">    br[x]+=b;<span class="comment">//向指定的X坐标累加亮度</span></span><br><span class="line">    maxx=max(maxx,x);<span class="comment">//更新x的最大值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxx;i++) sum[i]=sum[i<span class="number">-1</span>]+br[i];<span class="comment">//递推处理前缀和数组</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=w;i&lt;=maxx;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ans=max(ans,sum[i]-sum[i-w]);<span class="comment">//区间和与取最大值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图床推荐</title>
      <link href="/2019/%E5%9B%BE%E5%BA%8A%E6%8E%A8%E8%8D%90/"/>
      <url>/2019/%E5%9B%BE%E5%BA%8A%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<h1 id="十分推荐这个图床-https-sm-ms"><a href="#十分推荐这个图床-https-sm-ms" class="headerlink" title="十分推荐这个图床 https://sm.ms"></a>十分推荐这个图床 <a href="https://sm.ms" target="_blank" rel="noopener">https://sm.ms</a></h1><ul><li>当你想在洛谷讨论中分享图片，却发现图片被打上水印？</li><li>当你想上传高清图片时，却发现因为图片太大无法上传？</li></ul><p><strong>没关系！来 sm.ms 轻松解决!</strong></p><p><del>好了不废话了</del>以下进入正题</p><hr><h2 id="sm-ms-使用方法："><a href="#sm-ms-使用方法：" class="headerlink" title="sm.ms 使用方法："></a><strong>sm.ms 使用方法：</strong></h2><ol><li>在浏览器中输入 sm.ms ，界面如图 <a href="https://i.loli.net/2019/07/23/5d36feb19c3e173273.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/23/5d36feb19c3e173273.png" alt="TIM截图20190723203517.png"></a></li><li>将要上传的图片拖入中央写有“Drag &amp; drop files here”字样的矩形，或直接在单击底部蓝色“browse”按钮后在对话框中选择图片</li><li>选择好图片后，单击upload按钮完成上传 <a href="https://i.loli.net/2019/07/23/5d3700a9b25c235302.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/23/5d3700a9b25c235302.png" alt="TIM截图20190723204329.png"></a></li><li>等待上传完毕后，即可在底部的“URL”中复制链接，或在“Markdown”和“Markdown with link”中复制Markdown版链接 <a href="https://i.loli.net/2019/07/23/5d3701c936dd529271.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/23/5d3701c936dd529271.png" alt="TIM截图20190723204829.png"></a></li></ol><p>注：图床外链为一次性生成，但可永久使用</p>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分享一个快读</title>
      <link href="/2019/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E5%BF%AB%E8%AF%BB/"/>
      <url>/2019/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E5%BF%AB%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="如题"><a href="#如题" class="headerlink" title="如题"></a>如题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span> || ch&gt;<span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">'-'</span>) w=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span> &amp;&amp; ch&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">        s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);<span class="comment">//精华</span></span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P2782 【友好城市】</title>
      <link href="/2019/%E9%A2%98%E8%A7%A3-P2782-%E3%80%90%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82%E3%80%91/"/>
      <url>/2019/%E9%A2%98%E8%A7%A3-P2782-%E3%80%90%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="条件分析"><a href="#条件分析" class="headerlink" title="条件分析"></a>条件分析</h2><p>首先，我们分析一下航道不交叉的条件。</p><p> 如果有一条已经被批准的航道，南北坐标为N1,S1;</p><p> 则第二条N2&lt;N1,S2&gt;S1（或恰好相反）的航道将不能被批准，因为他们发生了交叉。</p><hr><p>参照此图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.N   .N</span><br><span class="line"> \   |</span><br><span class="line">  \  |</span><br><span class="line">   \ | </span><br><span class="line">    \|</span><br><span class="line">     |</span><br><span class="line">     |\</span><br><span class="line">     | \</span><br><span class="line">     .S .S</span><br></pre></td></tr></table></figure><hr><p>因此，要满足题目中的条件，需要保证南岸序列和北岸序列<strong>单调上升</strong>（题目中交代了坐标不会重合）。</p><p>我们可以按北岸坐标大小对城市进行排序，来保证北岸序列单调上升；</p><p>然后，南岸序列的<strong>最长上升子序列</strong>长度就是能够批准的航线条数。</p><h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><p>如何求出最长上升子序列的长度？</p><p>不难看出，这个问题用动态规划解决会很简单，</p><p>边界为f(1)=1</p><p>状态转移方程为f(i)=max{f(i),f(j)+1|S(i)&gt;s(j)} (i=1,i&lt;=n) (j=i+1,j&lt;=n)</p><p>然而 这题的数据规模。。。 n&lt;=200000;</p><p>n方的动态规划肯定TLE，我们得想点别的办法。</p><p>假设有一个序列 100 389 207 99 300，从前往后扫描；</p><ol><li>扫描到100，将100加入序列</li><li>扫描到389，将389加入序列尾部</li><li>扫描到207，将207替换掉389（因为它更小，可以让更多数插进来）</li><li>扫描到99，将99替换掉100（这不会使结果变差）</li><li>扫描到300，加入序列尾部（可以看出，如果不执行第三步的替换，这里会漏过最优解）</li></ol><p>因此，我们的策略是：如果当前数比序列尾更大，直接将其插入尾部，序列长度+1；</p><p>否则用它替换掉序列中比它大但又最小的一个（保持单调性）。</p><p>对于情况一，可在常数时间内完成；</p><p>对于情况二，STL中有现成的函数——lower_bound（这题upper_bound也可以），他的时间复杂度是logn，效率很高（其实就是二分查找）。</p><hr><p>贴代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">city</span>&#123;</span></span><br><span class="line"><span class="comment">//方便排序</span></span><br><span class="line">    <span class="keyword">int</span> north;<span class="comment">//北岸</span></span><br><span class="line">    <span class="keyword">int</span> south;<span class="comment">//南岸</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(city&amp; a,city&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.north&lt;b.north;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">city c[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> lis[<span class="number">200005</span>];<span class="comment">//LIS序列</span></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//LIS长度</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);<span class="comment">//流式I/O加速</span></span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c[i].north&gt;&gt;c[i].south;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(c+<span class="number">1</span>,c+n+<span class="number">1</span>,cmp());<span class="comment">//将城市按北岸排序，之后就没北岸什么事了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i].south&gt;lis[ans])<span class="comment">//如果能插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            lis[++ans]=c[i].south;<span class="comment">//插入至末尾</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//否则二分查找出序列中比它大但又最小的一个并替换</span></span><br><span class="line">            *lower_bound(lis+<span class="number">1</span>,lis+ans+<span class="number">1</span>,c[i].south)= (c[i].south);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h6 id="————写小白也能看懂的题解！"><a href="#————写小白也能看懂的题解！" class="headerlink" title="————写小白也能看懂的题解！"></a>————写小白也能看懂的题解！</h6>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三体精选</title>
      <link href="/2019/%E4%B8%89%E4%BD%93%E7%B2%BE%E9%80%89/"/>
      <url>/2019/%E4%B8%89%E4%BD%93%E7%B2%BE%E9%80%89/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.luogu.com.cn/upload/pic/63844.png" alt title="三体"></p><h1 id="《三体》精选："><a href="#《三体》精选：" class="headerlink" title="《三体》精选："></a>《三体》精选：</h1><h3 id="《三体I·地球往事》"><a href="#《三体I·地球往事》" class="headerlink" title="《三体I·地球往事》"></a>《三体I·地球往事》</h3><ul><li><p>你父亲在回忆这件事后，对我发出这样的感叹：在中国，任何超脱飞扬的思想都会砰然坠地的，现实的引力太沉重了。”<strong>——绍琳的父亲在和叶哲泰的回忆中发出的感叹，也许也是大刘借故事中的人物对中国科幻、中国现状的一种感叹吧</strong></p></li><li><p>“一切的一切都导向这样一个结果：物理学从来就没有存在过，将来也不会存在。我知道自己这样做是不负责任的，但别无选择。”<strong>——当杨冬留下这样的字句离去时，很多人都认为她过于脆弱……但就像丁仪说的,杨冬知道的肯定比他要多，想得也比他远，她知道一些很多物理学家都没看到的事儿，如果和杨冬多交流一些，可能丁仪也会一样离去</strong></p></li><li><p>“是的，整个人类历史也是偶然，从石器时代到今天，都没什么重大变故，真幸运。但既然是幸运，总有结束的一天；现在我告诉你，结束了，做好思想准备吧。”<strong>——常伟思将军让汪淼做好思想准备 我们故事的大幕也就一步步揭开了</strong></p></li><li><p>“你的无畏来源于无知。”<strong>——面对令人崩溃的现实，汪淼仍有着身为科学家的一种自负，对大史超脱的人生态度有些不以为然</strong></p></li><li><p>“旁观者清，千秋功罪，可真的有人评说了。”<strong>——这是中央上级对于“红岸”的【批示】，当我们阅尽三部作品，再来看这句话，难免唏嘘不已</strong></p></li><li><p>“空不是无，空是一种存在，你得用空这种存在填满自己。”<strong>——通过寺院里长老的指点，魏成想到了用三体问题来充填自己的人生。其实，我们的人生也未尝不需要寻找这样的“空”。</strong></p></li><li><p>“上帝是个无耻的老赌徒，他抛弃了我们！”<strong>——三体游戏中的爱因斯坦在看到三体是一个不可预测的混沌系统后说</strong></p></li><li><p>“齐家屯的生活是没有空白的，像古典的油画那样，充满着浓郁得化不开的色彩。一切都是浓烈和温热的:铺着厚厚乌拉草的火炕、铜烟锅里的关东烟和莫合烟、厚实的高粱饭、六十五度的高粱酒……但这一切，又都在宁静与平和中流逝着，像屯子边上的小溪一样。”<strong>——最令叶文洁难忘的是在齐家屯的夜晚，在那时她真正感受到对生活的眷恋</strong></p></li><li><p>“审问者:那你为什么对其抱有那样的期望，认为它们能够改造和完善人类社会呢？叶文洁:如果他们能够跨越星际来到我们的世界，说明他们的科学已经发展到相当的高度，一个科学如此昌明的社会，必然拥有更高的文明和道德水准。审问者:你认为这个结论，本身科学吗？叶文洁:……审问者:让我冒昧推测一下:你的父亲深受你祖父科学救国思想的影响，而你又深受父亲的影响。叶文洁(不为人察觉地叹息一声):我不知道。”<strong>——审问者的话一针见血，叶文洁坚持了数十年的信念如此经不起推敲，一击即溃。我们坚持的信念又到底是否受到自己经历的限制，而又无法自知呢……</strong></p></li><li><p>“这是人类的落日……”<strong>——叶文洁透过雷达峰、透过红岸基地的天空，仿佛看到了很远很远……</strong></p></li></ul><h3 id="《三体II·黑暗森林》"><a href="#《三体II·黑暗森林》" class="headerlink" title="《三体II·黑暗森林》"></a>《三体II·黑暗森林》</h3><ul><li><p>“城市就是森林，每一个男人都是猎手，每一个女人都是陷阱。”<strong>——《黑暗森林》的题目取自八十年代流行过的一句话，也契合了故事中的黑暗森林理论。</strong></p></li><li><p>“要多想。”“北海，我只能告诉你那以前要多想”<strong>——章北海从自己父亲的三个字中，用心读出了比三万字还多的内容，用自己的一生一步步坚实地向前走，他，同样也是面壁者。</strong></p></li><li><p>“我没让她笑啊？可那笑容已经留在记忆中，像冰上的水渍，永远擦不掉了。”<strong>——罗辑想象中的她第一次和罗辑有了交流，从此，思念像火一样燃烧起来……</strong></p></li><li><p>“不不，别说在哪儿！一知道在哪儿，世界就变得像一张地图那么小了；不知道在哪儿，感觉世界才广阔呢。”<strong>——有时候你也会想去这样一个地方：可以真正抛开一切，看不见喧嚣，听不到厌烦……不知道在哪儿，世界才广阔。</strong></p></li><li><p>“不是的，大部分人的爱情对象也只是存在于自己的想象之中。他们所爱的并不是现实中的她(他)，而只是想象中的她(他)，现室中的她(他)只是他们创造梦中情人的一个模板，他们迟早会发现梦中情人与模板之间的差异，如果适应这种差异他们就会走到一起，无法适应就分开，就这么简单。”<strong>——医生对罗辑爱上想象中幻影的诊断，作为对我们大多数人感情经历的诊断也未尝不可。</strong></p></li><li><p>“赶尽杀绝。”<strong>——罗辑眼中对一个文明的最高敬意</strong></p></li><li><p>“妈妈，我将变成一只萤火虫。”<strong>——这是一位即将出击的神风队员写给母亲的遗书，泰勒在执行他以毁灭地球舰队自身为代价的面壁计划过程中，脑海中总回响着这句话。</strong></p></li><li><p>“我正变成死亡，世界的毁灭者。”<strong>——奥本海默在看到第一颗核弹爆炸时说的一句话，引用了印度史诗《薄伽梵歌》，恒星级核弹设计者艾伦再次引用它时，雷迪亚兹以为别人洞穿了他的战略。</strong></p></li><li><p>“我在感谢您，雷迪亚兹先生，因为从此以后，我们不是婊子养的了。”<strong>——当人类能用自己的数学模型创造出一颗太阳时，当时的与事者如此感慨，科学带给了他们工作神圣的意义。</strong></p></li><li><p>“仇恨。”<strong>——当泰勒询问恐怖组织头目他们真正需要什么，并企图借以重建一支敢死队时，老人的回答令泰勒沉默。</strong></p></li><li><p>“无言是最大的轻蔑。”<strong>——当泰勒看到三体世界对自己战略的反应，一切的努力已无意义。之后，罗辑在与三体世界的对决中再次引用了这句话。言语中包含着尊严</strong></p></li><li><p>“光锥之内就是命运。”<strong>——宇宙中有多少重大事件的信息正在以光速向我们飞来，有些可能已经飞了上亿年，但我们仍在这些事件的光锥之外，斐兹罗将军以一个恰当的比喻，概括了智子窥视地球一切的事实。</strong></p></li><li><p>“给岁月以文明，而不是给文明以岁月。”<strong>——大低谷纪念碑前，危机纪元的社会提出了人文原则第一、文明延续第二的基础理念。该句套用了帕斯卡的一句话：给时光以生命，而不是给生命以时光。</strong></p></li><li><p>“Men always remember love because of romance only.”<strong>——东方延绪所设定的“自然选择”号的口令，其缩写就是Marlboro（万宝路，世界最畅销香烟品牌）。“男人会因为浪漫记住爱情”即万宝路的含义。</strong></p></li><li><p>“成吉思汗的骑兵，攻击速度与二十世纪的装甲部队相当；北宋的床弩，射程达一千五百米，与二十世纪的狙击步枪差不多；但这些仍不过是古代的骑兵与弓弩而已，不可能与现代力量抗衡。基础理论决定一切，未来史学派清楚地看到了这一点。而你们，却被回光返照的低级技术蒙住了眼睛。你们躺在现代文明的温床中安于享乐，对即将到来的决定人类命运的终极决战完全没有精神上的准备。”<strong>——章北海在与亚洲舰队司令的对话中，冷静地说出了未来史学派对战争形势的分析。他用集体的智慧作为自己坚定信念的来源</strong></p></li><li><p>“同为军人，知道我们之间最大的区别在哪里吗，你们按照可能的结果来决定自己的行动；而我们，不管结果如何，必须尽责任，这是唯一的机会，所以我就做了。”<strong>——尽管知道计划“不可能成功”，但章北海军人的本性还是促使他完成了自己的使命。这也是危机前的军人与危机纪元中的军人最大的区别。</strong></p></li><li><p>“我爱你，与你有何相干？”<strong>——丁仪信奉歌德对爱情的观念。丁仪不会去打扰他爱的那些人。这也不妨作为我们的爱情信仰……</strong></p></li><li><p>“黑，真他妈的黑啊。”<strong>——“终极规律”号的舰长自杀前最后一句话，也许他当时已经看透了宇宙的黑暗森林图景之后，当罗辑带大史推导这一图景时，大史在领悟的那一刻也说出了同样的话</strong></p></li><li><p>“没关系的，都一样。”<strong>——在长达一个月的黑暗对峙中，章北海只比对方慢了几秒钟。但是他在最后的时刻说出了这几个字。同样是新人类的诞生，谁留谁走，其实都一样。</strong></p></li><li><p>太阳快落下去了，你们的孩子居然不害怕？“当然不害怕，她知道明天太阳还会升起来的。”<strong>——罗辑和庄颜在《黑暗森林》故事的最后，提出了他们，也是人类纯真而稚嫩的愿望。叶文洁所说的“这是人类的落日”也许更能昭示宇宙中人类的未来，但我们，并不惧怕日落。</strong></p></li></ul><h3 id="《三体III·死神永生》"><a href="#《三体III·死神永生》" class="headerlink" title="《三体III·死神永生》"></a>《三体III·死神永生》</h3><ul><li><p>“大自然真是自然的吗？”<strong>——当看过绿眼镜为她演示了生命是如何影响地球之后，杨冬脑海里始终萦绕着这个问题。可能她那时已经知道自己现在的宇宙是受到了生命的影响的……宇宙正在死去。</strong></p></li><li><p>“好，你让我死，我就死吧”<strong>——卡夫卡的一篇小说里的主人公与父亲发生了口角，父亲随口骂道“你去死吧”，儿子立刻应声说“好，我去死”。当云天明得知姐姐想让自己安乐后，他终于理解了卡夫卡。</strong></p></li><li><p>“前进！前进！！不择手段地前进！！！”<strong>——这是维德一贯秉持的信念，贯穿整个人类斗争的过程中，维德是最具男人秉性的。</strong></p></li><li><p>“明天会更好。”<strong>——《时间之外的往事》（节选）这句话的价值在于文后对于它的分析：其实人们拥有这个信念只是近两三个世纪的事情，更早的时候这个想法可能很可笑。比如欧洲中世纪与千年前的古罗马时代相比，不但物质更贫困，精神上也更压抑；至于中国，魏晋南北朝与汉朝相比，元明与唐宋相比，都糟糕了许多。</strong></p></li><li><p>“这游戏真有趣，是吧？”<strong>——维德同程心用眼神交流云天明不宣誓的做法。在那一刻，云天明仿佛也自己给自己背负上了面壁者的使命，因为地球上，有他留恋的东西。</strong></p></li><li><p>“如果千秋功罪真是有人评说，现在已经可以派一个去解释岁月造成的误会”<strong>——这句话似乎在呼应第一部中那句“千秋功罪，可真的有人评说了”，程心被派往未来，希望阶梯计划不被未来所遗忘或误解。</strong></p></li><li><p>“那个篝火余烬旁的孩子，由外向乐观变得孤僻自闭了”<strong>——《时间之外的往事》（节选）中这样描述黑暗森林理论对人类文明深远的影响。</strong></p></li><li><p>“五分钟。”<strong>——美国的一位高中教师在班级里试验微型的纳粹社会，最后这场以游戏开始的教学试验几乎失控。当事人写过一本书，名叫《极权只需五天》。当人类真正流落太空时，极权只需五分钟。</strong></p></li><li><p>“真正进入太空的人，再也不是人了。所以，人们，当你们打算飞向外太空再也不回头时，请千万慎重，需付出的代价比你们想象的要大的多。”<strong>——“青铜时代”号舰长斯科特在法庭上做的最后陈述</strong></p></li><li><p>“不要返航，这里不是家！”<strong>——史耐德用尽最后的生命，嘶哑地喊出对“蓝色空间”号的警告。两艘飞船打破的是人类的底线，但是，不应该有人为此负责，因为，宇宙黑暗怀抱迎接的，是新人类。</strong></p></li><li><p>“宇宙在我眼里，已经由所有美和信仰的寄托物变成了一具膨胀的尸体……”<strong>——关一帆在经历了四维宇宙空间之后，联想到光永远不可能从宇宙的一端传到另一端，带着无望发出感慨。</strong></p></li><li><p>“像坟墓一样简洁。”<strong>——罗辑对威慑控制中心的要求，在这里，罗辑的目光中只有决定两个世界生死的达摩克利斯之剑</strong></p></li><li><p>“因为宇宙不是童话。”<strong>——程心喃喃地询问智子水滴摧毁引力波天线的原因，智子告诉她，在程心的潜意识里，宇宙人世一个童话，她最大的错误，就是没有真正站在敌人的立场上看问题。</strong></p></li><li><p>“当初我们为什么选择了你？”<strong>——随着三体舰队的逼近，全球移民的开始又一次考验了人类的生存底线。程心从一名军官的眼神中读出了这样的质问……但是这质问是对全人类，而不是程心。就像智子说的，程心不必自责，人们选择了她，也就选择了这个结局，全人类里面，只有程心是无辜的。</strong></p></li><li><p>“粮食？这不都是粮食？每个人看看你们的周围，都是粮食，活生生的粮食。”<strong>——三体世界改变了他们的灭绝计划，而做出了更为可怕的举动，他们要将人类变成非人。在智子话音落下的一刻，不知道有谁有勇气看向周围，或者说，谁更理智到非人。</strong></p></li><li><p>“有一颗遥远的星星，是夜空中一个隐约可见的光点，所有随便望了它一眼的人都说，那颗星星是安全的。”<strong>——宇宙安全声明的描述性解释。</strong></p></li><li><p>“宇宙很大，生活更大，也许以后还有缘相见。”<strong>——三体世界和智子向人类社会告别，离别之时，智子对程心和罗辑这样说道。到了时间之外，我们的宇宙，她们真的再一次相见。</strong></p></li><li><p>“好，在我们的星星。”<strong>——云天明和程心在跨越光年的注视中，约定了相会的地点。</strong></p></li><li><p>“死亡是唯一一座永远亮着的灯塔，不管你向哪里航行，最终都得转向它指引的方向。一切都会逝去，只有死神永生。”<strong>——默斯肯岛上的老人杰森远望海上灯塔发出的光，悟出这样的至理。也就是《死神永生》的主题。</strong></p></li><li><p>“因为只有在这个选择中，人是大写的。”<strong>——维德询问程心为什么选择光速飞船而非掩体、黑域计划，程心勇敢地迎接他的目光。</strong></p></li><li><p>“失去人性，失去很多；失去兽性，失去一切。”<strong>——维德无助地乞求程心做最后的决断。当程心依旧选择人性之时……维德的目光黯淡下来，有什么东西永远熄灭了。</strong></p></li><li><p>“藏好自己，做好清理。”<strong>——具有隐藏基因和清理基因的宇宙高级文明遵循的生存原则</strong></p></li><li><p>“弱小和无知不是生存的障碍，傲慢才是。”<strong>——每个文明每个人都是从无知和弱小发展开来，但是若不知敬畏，只会为自己的愚蠢付出代价。水滴是，纸条是……此后，宇宙再没给人类机会。</strong></p></li><li><p>“把字刻在石头上。”<strong>——最古老的方式却是保留信息最长久的方式。</strong></p></li><li><p>“我不知道你在这儿，知道的话我会常来看你的。”<strong>——当罗辑再次面对《蒙娜丽莎》时，他看向时光的深处，对着恋人喃喃地低语，深陷的双眼中有了泪光。</strong></p></li><li><p>“但谁也不知道，真相是不是比猜测更黑暗……有一点是肯定的：宇宙正在死去。”<strong>——关一帆和程心一起推测着宇宙比黑暗森林更加可怕的大图景</strong></p></li><li><p>“我知道你作为执剑人的经历，只是想说，你没有错。人类世界选择了你，就是选择了用爱来对待生命和一切，尽管要付出巨大的代价。你实现了那个世界的愿望，实现了那里的价值观，你实现了他们的选择，你真的没有错。”<strong>——关一帆对程心的安慰让我们想起了罗辑的演讲，人类之所以迟迟没有看透宇宙的黑暗森林状态，并不是由于文明进化不成熟而缺少宇宙意识。尽管幼稚地选择了程心为执剑人，但程心没有错，人类也没有错。作为地球文明的价值就是用爱来对待生命和一切。</strong></p></li></ul><p>原链接：<a href="https://www.zhihu.com/question/19579982/answer/15654431" target="_blank" rel="noopener">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 主站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【置顶】Crash Report</title>
      <link href="/2019/Crash-Report/"/>
      <url>/2019/Crash-Report/</url>
      
        <content type="html"><![CDATA[<p> 由于某些乱七八糟的原因，电脑上的博客文件夹没了。。。</p><p>搞得我又用Hexo搭了一遍（这可真糟糕）</p><p>新的Blog加装了一个Live2D模型（没错，就是你在右下角看到的东西）</p><p>正在加入统计和PWA功能</p><p>（To Be Continued)</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
